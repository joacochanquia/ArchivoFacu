!SESSION 2022-03-23 19:50:12.327 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product -data C:\Users\Joaco\Desktop\Progra 3 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-23 19:50:16.064
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-23 19:50:16.064
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@195498aa,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4b360972,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-23 19:50:16.064
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@793d09e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@68821f6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-23 19:50:19.643
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-24 12:54:35.169 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-24 12:54:58.835
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-24 12:54:58.835
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@304068,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@54d60fa1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-24 12:54:58.835
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1cb849b2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6fe2a366,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-24 12:55:01.537
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-24 21:19:57.591 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-24 21:20:05.413
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-24 21:20:05.413
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1cb849b2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6fe2a366,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-24 21:20:05.413
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6dd38df2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@99c3cee,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-24 21:20:09.763
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-25 18:19:53.998 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-25 18:20:00.001
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-25 18:20:00.001
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@304068,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@54d60fa1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-25 18:20:00.001
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1cb849b2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6fe2a366,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-25 18:20:02.908
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.debug 4 125 2022-03-25 19:28:45.042
!MESSAGE Internal error logged from JDI Debug: 
!STACK 1
org.eclipse.debug.core.DebugException: Breakpoint does not have an associated marker.
	at org.eclipse.debug.core.model.Breakpoint.ensureMarker(Breakpoint.java:297)
	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.getTypeName(JavaBreakpoint.java:926)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.lambda$1(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsResource(JDIDebugTarget.java:1431)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsBreakpoint(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.breakpointRemoved(JDIDebugTarget.java:1672)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.run(BreakpointManager.java:1030)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.notify(BreakpointManager.java:1054)
	at org.eclipse.debug.internal.core.BreakpointManager.fireUpdate(BreakpointManager.java:962)
	at org.eclipse.debug.internal.core.BreakpointManager.removeBreakpoints(BreakpointManager.java:509)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointManagerVisitor.update(BreakpointManager.java:758)
	at org.eclipse.debug.internal.core.BreakpointManager.resourceChanged(BreakpointManager.java:695)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:305)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:295)
	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:158)
	at org.eclipse.core.internal.resources.Workspace.broadcastBuildEvent(Workspace.java:367)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:164)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.debug.core 4 5012 2022-03-25 19:28:45.043
!MESSAGE Breakpoint does not have an associated marker.

!ENTRY org.eclipse.jdt.debug 4 125 2022-03-25 19:28:45.045
!MESSAGE Internal error logged from JDI Debug: 
!STACK 1
org.eclipse.debug.core.DebugException: Breakpoint does not have an associated marker.
	at org.eclipse.debug.core.model.Breakpoint.ensureMarker(Breakpoint.java:297)
	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.getTypeName(JavaBreakpoint.java:926)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.lambda$1(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsResource(JDIDebugTarget.java:1431)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsBreakpoint(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.breakpointRemoved(JDIDebugTarget.java:1672)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.run(BreakpointManager.java:1030)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.notify(BreakpointManager.java:1054)
	at org.eclipse.debug.internal.core.BreakpointManager.fireUpdate(BreakpointManager.java:962)
	at org.eclipse.debug.internal.core.BreakpointManager.removeBreakpoints(BreakpointManager.java:509)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointManagerVisitor.update(BreakpointManager.java:758)
	at org.eclipse.debug.internal.core.BreakpointManager.resourceChanged(BreakpointManager.java:695)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:305)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:295)
	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:158)
	at org.eclipse.core.internal.resources.Workspace.broadcastBuildEvent(Workspace.java:367)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:164)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.debug.core 4 5012 2022-03-25 19:28:45.045
!MESSAGE Breakpoint does not have an associated marker.

!ENTRY org.eclipse.jdt.debug 4 125 2022-03-25 19:28:45.047
!MESSAGE Internal error logged from JDI Debug: 
!STACK 1
org.eclipse.debug.core.DebugException: Breakpoint does not have an associated marker.
	at org.eclipse.debug.core.model.Breakpoint.ensureMarker(Breakpoint.java:297)
	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.getTypeName(JavaBreakpoint.java:926)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.lambda$1(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsResource(JDIDebugTarget.java:1431)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsBreakpoint(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.breakpointRemoved(JDIDebugTarget.java:1672)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.run(BreakpointManager.java:1030)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.notify(BreakpointManager.java:1054)
	at org.eclipse.debug.internal.core.BreakpointManager.fireUpdate(BreakpointManager.java:962)
	at org.eclipse.debug.internal.core.BreakpointManager.removeBreakpoints(BreakpointManager.java:509)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointManagerVisitor.update(BreakpointManager.java:758)
	at org.eclipse.debug.internal.core.BreakpointManager.resourceChanged(BreakpointManager.java:695)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:305)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:295)
	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:158)
	at org.eclipse.core.internal.resources.Workspace.broadcastBuildEvent(Workspace.java:367)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:164)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.debug.core 4 5012 2022-03-25 19:28:45.047
!MESSAGE Breakpoint does not have an associated marker.

!ENTRY org.eclipse.jdt.debug 4 125 2022-03-25 19:28:45.049
!MESSAGE Internal error logged from JDI Debug: 
!STACK 1
org.eclipse.debug.core.DebugException: Breakpoint does not have an associated marker.
	at org.eclipse.debug.core.model.Breakpoint.ensureMarker(Breakpoint.java:297)
	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.getTypeName(JavaBreakpoint.java:926)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.lambda$1(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsResource(JDIDebugTarget.java:1431)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsBreakpoint(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.breakpointRemoved(JDIDebugTarget.java:1672)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.run(BreakpointManager.java:1030)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.notify(BreakpointManager.java:1054)
	at org.eclipse.debug.internal.core.BreakpointManager.fireUpdate(BreakpointManager.java:962)
	at org.eclipse.debug.internal.core.BreakpointManager.removeBreakpoints(BreakpointManager.java:509)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointManagerVisitor.update(BreakpointManager.java:758)
	at org.eclipse.debug.internal.core.BreakpointManager.resourceChanged(BreakpointManager.java:695)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:305)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:295)
	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:158)
	at org.eclipse.core.internal.resources.Workspace.broadcastBuildEvent(Workspace.java:367)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:164)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.debug.core 4 5012 2022-03-25 19:28:45.049
!MESSAGE Breakpoint does not have an associated marker.

!ENTRY org.eclipse.jdt.debug 4 125 2022-03-25 19:28:45.051
!MESSAGE Internal error logged from JDI Debug: 
!STACK 1
org.eclipse.debug.core.DebugException: Breakpoint does not have an associated marker.
	at org.eclipse.debug.core.model.Breakpoint.ensureMarker(Breakpoint.java:297)
	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.getTypeName(JavaBreakpoint.java:926)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.lambda$1(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsResource(JDIDebugTarget.java:1431)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsBreakpoint(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.breakpointRemoved(JDIDebugTarget.java:1672)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.run(BreakpointManager.java:1030)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.notify(BreakpointManager.java:1054)
	at org.eclipse.debug.internal.core.BreakpointManager.fireUpdate(BreakpointManager.java:962)
	at org.eclipse.debug.internal.core.BreakpointManager.removeBreakpoints(BreakpointManager.java:509)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointManagerVisitor.update(BreakpointManager.java:758)
	at org.eclipse.debug.internal.core.BreakpointManager.resourceChanged(BreakpointManager.java:695)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:305)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:295)
	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:158)
	at org.eclipse.core.internal.resources.Workspace.broadcastBuildEvent(Workspace.java:367)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:164)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.debug.core 4 5012 2022-03-25 19:28:45.051
!MESSAGE Breakpoint does not have an associated marker.

!ENTRY org.eclipse.jdt.debug 4 125 2022-03-25 19:28:45.053
!MESSAGE Internal error logged from JDI Debug: 
!STACK 1
org.eclipse.debug.core.DebugException: Breakpoint does not have an associated marker.
	at org.eclipse.debug.core.model.Breakpoint.ensureMarker(Breakpoint.java:297)
	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.getTypeName(JavaBreakpoint.java:926)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.lambda$1(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsResource(JDIDebugTarget.java:1431)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsBreakpoint(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.breakpointRemoved(JDIDebugTarget.java:1672)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.run(BreakpointManager.java:1030)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.notify(BreakpointManager.java:1054)
	at org.eclipse.debug.internal.core.BreakpointManager.fireUpdate(BreakpointManager.java:962)
	at org.eclipse.debug.internal.core.BreakpointManager.removeBreakpoints(BreakpointManager.java:509)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointManagerVisitor.update(BreakpointManager.java:758)
	at org.eclipse.debug.internal.core.BreakpointManager.resourceChanged(BreakpointManager.java:695)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:305)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:295)
	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:158)
	at org.eclipse.core.internal.resources.Workspace.broadcastBuildEvent(Workspace.java:367)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:164)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.debug.core 4 5012 2022-03-25 19:28:45.053
!MESSAGE Breakpoint does not have an associated marker.

!ENTRY org.eclipse.jdt.debug 4 125 2022-03-25 19:37:54.321
!MESSAGE Internal error logged from JDI Debug: 
!STACK 1
org.eclipse.debug.core.DebugException: Breakpoint does not have an associated marker.
	at org.eclipse.debug.core.model.Breakpoint.ensureMarker(Breakpoint.java:297)
	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.getTypeName(JavaBreakpoint.java:926)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.lambda$1(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsResource(JDIDebugTarget.java:1431)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsBreakpoint(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.breakpointRemoved(JDIDebugTarget.java:1672)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.run(BreakpointManager.java:1030)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.notify(BreakpointManager.java:1054)
	at org.eclipse.debug.internal.core.BreakpointManager.fireUpdate(BreakpointManager.java:962)
	at org.eclipse.debug.internal.core.BreakpointManager.removeBreakpoints(BreakpointManager.java:509)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointManagerVisitor.update(BreakpointManager.java:758)
	at org.eclipse.debug.internal.core.BreakpointManager.resourceChanged(BreakpointManager.java:695)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:305)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:295)
	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:158)
	at org.eclipse.core.internal.resources.Workspace.broadcastBuildEvent(Workspace.java:367)
	at org.eclipse.core.internal.resources.Workspace.buildInternal(Workspace.java:531)
	at org.eclipse.core.internal.resources.Workspace.build(Workspace.java:406)
	at org.eclipse.ui.actions.GlobalBuildAction$1.run(GlobalBuildAction.java:180)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.debug.core 4 5012 2022-03-25 19:37:54.322
!MESSAGE Breakpoint does not have an associated marker.

!ENTRY org.eclipse.jdt.debug 4 125 2022-03-25 19:37:54.325
!MESSAGE Internal error logged from JDI Debug: 
!STACK 1
org.eclipse.debug.core.DebugException: Breakpoint does not have an associated marker.
	at org.eclipse.debug.core.model.Breakpoint.ensureMarker(Breakpoint.java:297)
	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.getTypeName(JavaBreakpoint.java:926)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.lambda$1(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsResource(JDIDebugTarget.java:1431)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsBreakpoint(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.breakpointRemoved(JDIDebugTarget.java:1672)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.run(BreakpointManager.java:1030)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.notify(BreakpointManager.java:1054)
	at org.eclipse.debug.internal.core.BreakpointManager.fireUpdate(BreakpointManager.java:962)
	at org.eclipse.debug.internal.core.BreakpointManager.removeBreakpoints(BreakpointManager.java:509)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointManagerVisitor.update(BreakpointManager.java:758)
	at org.eclipse.debug.internal.core.BreakpointManager.resourceChanged(BreakpointManager.java:695)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:305)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:295)
	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:158)
	at org.eclipse.core.internal.resources.Workspace.broadcastBuildEvent(Workspace.java:367)
	at org.eclipse.core.internal.resources.Workspace.buildInternal(Workspace.java:531)
	at org.eclipse.core.internal.resources.Workspace.build(Workspace.java:406)
	at org.eclipse.ui.actions.GlobalBuildAction$1.run(GlobalBuildAction.java:180)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.debug.core 4 5012 2022-03-25 19:37:54.325
!MESSAGE Breakpoint does not have an associated marker.

!ENTRY org.eclipse.jdt.debug 4 125 2022-03-25 19:37:54.327
!MESSAGE Internal error logged from JDI Debug: 
!STACK 1
org.eclipse.debug.core.DebugException: Breakpoint does not have an associated marker.
	at org.eclipse.debug.core.model.Breakpoint.ensureMarker(Breakpoint.java:297)
	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.getTypeName(JavaBreakpoint.java:926)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.lambda$1(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsResource(JDIDebugTarget.java:1431)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsBreakpoint(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.breakpointRemoved(JDIDebugTarget.java:1672)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.run(BreakpointManager.java:1030)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.notify(BreakpointManager.java:1054)
	at org.eclipse.debug.internal.core.BreakpointManager.fireUpdate(BreakpointManager.java:962)
	at org.eclipse.debug.internal.core.BreakpointManager.removeBreakpoints(BreakpointManager.java:509)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointManagerVisitor.update(BreakpointManager.java:758)
	at org.eclipse.debug.internal.core.BreakpointManager.resourceChanged(BreakpointManager.java:695)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:305)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:295)
	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:158)
	at org.eclipse.core.internal.resources.Workspace.broadcastBuildEvent(Workspace.java:367)
	at org.eclipse.core.internal.resources.Workspace.buildInternal(Workspace.java:531)
	at org.eclipse.core.internal.resources.Workspace.build(Workspace.java:406)
	at org.eclipse.ui.actions.GlobalBuildAction$1.run(GlobalBuildAction.java:180)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.debug.core 4 5012 2022-03-25 19:37:54.327
!MESSAGE Breakpoint does not have an associated marker.

!ENTRY org.eclipse.jdt.debug 4 125 2022-03-25 19:37:54.329
!MESSAGE Internal error logged from JDI Debug: 
!STACK 1
org.eclipse.debug.core.DebugException: Breakpoint does not have an associated marker.
	at org.eclipse.debug.core.model.Breakpoint.ensureMarker(Breakpoint.java:297)
	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.getTypeName(JavaBreakpoint.java:926)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.lambda$1(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsResource(JDIDebugTarget.java:1431)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsBreakpoint(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.breakpointRemoved(JDIDebugTarget.java:1672)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.run(BreakpointManager.java:1030)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.notify(BreakpointManager.java:1054)
	at org.eclipse.debug.internal.core.BreakpointManager.fireUpdate(BreakpointManager.java:962)
	at org.eclipse.debug.internal.core.BreakpointManager.removeBreakpoints(BreakpointManager.java:509)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointManagerVisitor.update(BreakpointManager.java:758)
	at org.eclipse.debug.internal.core.BreakpointManager.resourceChanged(BreakpointManager.java:695)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:305)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:295)
	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:158)
	at org.eclipse.core.internal.resources.Workspace.broadcastBuildEvent(Workspace.java:367)
	at org.eclipse.core.internal.resources.Workspace.buildInternal(Workspace.java:531)
	at org.eclipse.core.internal.resources.Workspace.build(Workspace.java:406)
	at org.eclipse.ui.actions.GlobalBuildAction$1.run(GlobalBuildAction.java:180)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.debug.core 4 5012 2022-03-25 19:37:54.329
!MESSAGE Breakpoint does not have an associated marker.

!ENTRY org.eclipse.jdt.debug 4 125 2022-03-25 19:37:54.331
!MESSAGE Internal error logged from JDI Debug: 
!STACK 1
org.eclipse.debug.core.DebugException: Breakpoint does not have an associated marker.
	at org.eclipse.debug.core.model.Breakpoint.ensureMarker(Breakpoint.java:297)
	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.getTypeName(JavaBreakpoint.java:926)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.lambda$1(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsResource(JDIDebugTarget.java:1431)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsBreakpoint(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.breakpointRemoved(JDIDebugTarget.java:1672)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.run(BreakpointManager.java:1030)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.notify(BreakpointManager.java:1054)
	at org.eclipse.debug.internal.core.BreakpointManager.fireUpdate(BreakpointManager.java:962)
	at org.eclipse.debug.internal.core.BreakpointManager.removeBreakpoints(BreakpointManager.java:509)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointManagerVisitor.update(BreakpointManager.java:758)
	at org.eclipse.debug.internal.core.BreakpointManager.resourceChanged(BreakpointManager.java:695)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:305)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:295)
	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:158)
	at org.eclipse.core.internal.resources.Workspace.broadcastBuildEvent(Workspace.java:367)
	at org.eclipse.core.internal.resources.Workspace.buildInternal(Workspace.java:531)
	at org.eclipse.core.internal.resources.Workspace.build(Workspace.java:406)
	at org.eclipse.ui.actions.GlobalBuildAction$1.run(GlobalBuildAction.java:180)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.debug.core 4 5012 2022-03-25 19:37:54.331
!MESSAGE Breakpoint does not have an associated marker.

!ENTRY org.eclipse.jdt.debug 4 125 2022-03-25 19:41:33.103
!MESSAGE Internal error logged from JDI Debug: 
!STACK 1
org.eclipse.debug.core.DebugException: Breakpoint does not have an associated marker.
	at org.eclipse.debug.core.model.Breakpoint.ensureMarker(Breakpoint.java:297)
	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.getTypeName(JavaBreakpoint.java:926)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.lambda$1(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsResource(JDIDebugTarget.java:1431)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsBreakpoint(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.breakpointRemoved(JDIDebugTarget.java:1672)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.run(BreakpointManager.java:1030)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.notify(BreakpointManager.java:1054)
	at org.eclipse.debug.internal.core.BreakpointManager.fireUpdate(BreakpointManager.java:962)
	at org.eclipse.debug.internal.core.BreakpointManager.removeBreakpoints(BreakpointManager.java:509)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointManagerVisitor.update(BreakpointManager.java:758)
	at org.eclipse.debug.internal.core.BreakpointManager.resourceChanged(BreakpointManager.java:695)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:305)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:295)
	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:158)
	at org.eclipse.core.internal.resources.Workspace.broadcastBuildEvent(Workspace.java:367)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:164)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.debug.core 4 5012 2022-03-25 19:41:33.104
!MESSAGE Breakpoint does not have an associated marker.

!ENTRY org.eclipse.jdt.debug 4 125 2022-03-25 19:41:33.105
!MESSAGE Internal error logged from JDI Debug: 
!STACK 1
org.eclipse.debug.core.DebugException: Breakpoint does not have an associated marker.
	at org.eclipse.debug.core.model.Breakpoint.ensureMarker(Breakpoint.java:297)
	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.getTypeName(JavaBreakpoint.java:926)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.lambda$1(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsResource(JDIDebugTarget.java:1431)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsBreakpoint(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.breakpointRemoved(JDIDebugTarget.java:1672)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.run(BreakpointManager.java:1030)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.notify(BreakpointManager.java:1054)
	at org.eclipse.debug.internal.core.BreakpointManager.fireUpdate(BreakpointManager.java:962)
	at org.eclipse.debug.internal.core.BreakpointManager.removeBreakpoints(BreakpointManager.java:509)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointManagerVisitor.update(BreakpointManager.java:758)
	at org.eclipse.debug.internal.core.BreakpointManager.resourceChanged(BreakpointManager.java:695)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:305)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:295)
	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:158)
	at org.eclipse.core.internal.resources.Workspace.broadcastBuildEvent(Workspace.java:367)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:164)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.debug.core 4 5012 2022-03-25 19:41:33.105
!MESSAGE Breakpoint does not have an associated marker.

!ENTRY org.eclipse.jdt.debug 4 125 2022-03-25 19:41:33.107
!MESSAGE Internal error logged from JDI Debug: 
!STACK 1
org.eclipse.debug.core.DebugException: Breakpoint does not have an associated marker.
	at org.eclipse.debug.core.model.Breakpoint.ensureMarker(Breakpoint.java:297)
	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.getTypeName(JavaBreakpoint.java:926)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.lambda$1(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsResource(JDIDebugTarget.java:1431)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsBreakpoint(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.breakpointRemoved(JDIDebugTarget.java:1672)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.run(BreakpointManager.java:1030)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.notify(BreakpointManager.java:1054)
	at org.eclipse.debug.internal.core.BreakpointManager.fireUpdate(BreakpointManager.java:962)
	at org.eclipse.debug.internal.core.BreakpointManager.removeBreakpoints(BreakpointManager.java:509)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointManagerVisitor.update(BreakpointManager.java:758)
	at org.eclipse.debug.internal.core.BreakpointManager.resourceChanged(BreakpointManager.java:695)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:305)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:295)
	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:158)
	at org.eclipse.core.internal.resources.Workspace.broadcastBuildEvent(Workspace.java:367)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:164)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.debug.core 4 5012 2022-03-25 19:41:33.107
!MESSAGE Breakpoint does not have an associated marker.

!ENTRY org.eclipse.jdt.debug 4 125 2022-03-25 19:41:33.108
!MESSAGE Internal error logged from JDI Debug: 
!STACK 1
org.eclipse.debug.core.DebugException: Breakpoint does not have an associated marker.
	at org.eclipse.debug.core.model.Breakpoint.ensureMarker(Breakpoint.java:297)
	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.getTypeName(JavaBreakpoint.java:926)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.lambda$1(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsResource(JDIDebugTarget.java:1431)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsBreakpoint(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.breakpointRemoved(JDIDebugTarget.java:1672)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.run(BreakpointManager.java:1030)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.notify(BreakpointManager.java:1054)
	at org.eclipse.debug.internal.core.BreakpointManager.fireUpdate(BreakpointManager.java:962)
	at org.eclipse.debug.internal.core.BreakpointManager.removeBreakpoints(BreakpointManager.java:509)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointManagerVisitor.update(BreakpointManager.java:758)
	at org.eclipse.debug.internal.core.BreakpointManager.resourceChanged(BreakpointManager.java:695)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:305)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:295)
	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:158)
	at org.eclipse.core.internal.resources.Workspace.broadcastBuildEvent(Workspace.java:367)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:164)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.debug.core 4 5012 2022-03-25 19:41:33.108
!MESSAGE Breakpoint does not have an associated marker.

!ENTRY org.eclipse.jdt.debug 4 125 2022-03-25 19:41:33.111
!MESSAGE Internal error logged from JDI Debug: 
!STACK 1
org.eclipse.debug.core.DebugException: Breakpoint does not have an associated marker.
	at org.eclipse.debug.core.model.Breakpoint.ensureMarker(Breakpoint.java:297)
	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.getTypeName(JavaBreakpoint.java:926)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.lambda$1(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsResource(JDIDebugTarget.java:1431)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsBreakpoint(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.breakpointRemoved(JDIDebugTarget.java:1672)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.run(BreakpointManager.java:1030)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.notify(BreakpointManager.java:1054)
	at org.eclipse.debug.internal.core.BreakpointManager.fireUpdate(BreakpointManager.java:962)
	at org.eclipse.debug.internal.core.BreakpointManager.removeBreakpoints(BreakpointManager.java:509)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointManagerVisitor.update(BreakpointManager.java:758)
	at org.eclipse.debug.internal.core.BreakpointManager.resourceChanged(BreakpointManager.java:695)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:305)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:295)
	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:158)
	at org.eclipse.core.internal.resources.Workspace.broadcastBuildEvent(Workspace.java:367)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:164)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.debug.core 4 5012 2022-03-25 19:41:33.111
!MESSAGE Breakpoint does not have an associated marker.

!ENTRY org.eclipse.jdt.debug 4 125 2022-03-25 19:41:33.112
!MESSAGE Internal error logged from JDI Debug: 
!STACK 1
org.eclipse.debug.core.DebugException: Breakpoint does not have an associated marker.
	at org.eclipse.debug.core.model.Breakpoint.ensureMarker(Breakpoint.java:297)
	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.getTypeName(JavaBreakpoint.java:926)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.lambda$1(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsResource(JDIDebugTarget.java:1431)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsBreakpoint(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.breakpointRemoved(JDIDebugTarget.java:1672)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.run(BreakpointManager.java:1030)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.notify(BreakpointManager.java:1054)
	at org.eclipse.debug.internal.core.BreakpointManager.fireUpdate(BreakpointManager.java:962)
	at org.eclipse.debug.internal.core.BreakpointManager.removeBreakpoints(BreakpointManager.java:509)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointManagerVisitor.update(BreakpointManager.java:758)
	at org.eclipse.debug.internal.core.BreakpointManager.resourceChanged(BreakpointManager.java:695)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:305)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:295)
	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:158)
	at org.eclipse.core.internal.resources.Workspace.broadcastBuildEvent(Workspace.java:367)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:164)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.debug.core 4 5012 2022-03-25 19:41:33.112
!MESSAGE Breakpoint does not have an associated marker.

!ENTRY org.eclipse.jdt.debug 4 125 2022-03-25 19:41:33.113
!MESSAGE Internal error logged from JDI Debug: 
!STACK 1
org.eclipse.debug.core.DebugException: Breakpoint does not have an associated marker.
	at org.eclipse.debug.core.model.Breakpoint.ensureMarker(Breakpoint.java:297)
	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.getTypeName(JavaBreakpoint.java:926)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.lambda$1(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsResource(JDIDebugTarget.java:1431)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsBreakpoint(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.breakpointRemoved(JDIDebugTarget.java:1672)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.run(BreakpointManager.java:1030)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.notify(BreakpointManager.java:1054)
	at org.eclipse.debug.internal.core.BreakpointManager.fireUpdate(BreakpointManager.java:962)
	at org.eclipse.debug.internal.core.BreakpointManager.removeBreakpoints(BreakpointManager.java:509)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointManagerVisitor.update(BreakpointManager.java:758)
	at org.eclipse.debug.internal.core.BreakpointManager.resourceChanged(BreakpointManager.java:695)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:305)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:295)
	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:158)
	at org.eclipse.core.internal.resources.Workspace.broadcastBuildEvent(Workspace.java:367)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:164)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.debug.core 4 5012 2022-03-25 19:41:33.113
!MESSAGE Breakpoint does not have an associated marker.

!ENTRY org.eclipse.jdt.debug 4 125 2022-03-25 19:41:33.114
!MESSAGE Internal error logged from JDI Debug: 
!STACK 1
org.eclipse.debug.core.DebugException: Breakpoint does not have an associated marker.
	at org.eclipse.debug.core.model.Breakpoint.ensureMarker(Breakpoint.java:297)
	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.getTypeName(JavaBreakpoint.java:926)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.lambda$1(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsResource(JDIDebugTarget.java:1431)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsBreakpoint(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.breakpointRemoved(JDIDebugTarget.java:1672)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.run(BreakpointManager.java:1030)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.notify(BreakpointManager.java:1054)
	at org.eclipse.debug.internal.core.BreakpointManager.fireUpdate(BreakpointManager.java:962)
	at org.eclipse.debug.internal.core.BreakpointManager.removeBreakpoints(BreakpointManager.java:509)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointManagerVisitor.update(BreakpointManager.java:758)
	at org.eclipse.debug.internal.core.BreakpointManager.resourceChanged(BreakpointManager.java:695)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:305)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:295)
	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:158)
	at org.eclipse.core.internal.resources.Workspace.broadcastBuildEvent(Workspace.java:367)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:164)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.debug.core 4 5012 2022-03-25 19:41:33.114
!MESSAGE Breakpoint does not have an associated marker.

!ENTRY org.eclipse.jdt.debug 4 125 2022-03-25 19:41:33.116
!MESSAGE Internal error logged from JDI Debug: 
!STACK 1
org.eclipse.debug.core.DebugException: Breakpoint does not have an associated marker.
	at org.eclipse.debug.core.model.Breakpoint.ensureMarker(Breakpoint.java:297)
	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.getTypeName(JavaBreakpoint.java:926)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.lambda$1(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsResource(JDIDebugTarget.java:1431)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsBreakpoint(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.breakpointRemoved(JDIDebugTarget.java:1672)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.run(BreakpointManager.java:1030)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.notify(BreakpointManager.java:1054)
	at org.eclipse.debug.internal.core.BreakpointManager.fireUpdate(BreakpointManager.java:962)
	at org.eclipse.debug.internal.core.BreakpointManager.removeBreakpoints(BreakpointManager.java:509)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointManagerVisitor.update(BreakpointManager.java:758)
	at org.eclipse.debug.internal.core.BreakpointManager.resourceChanged(BreakpointManager.java:695)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:305)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:295)
	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:158)
	at org.eclipse.core.internal.resources.Workspace.broadcastBuildEvent(Workspace.java:367)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:164)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.debug.core 4 5012 2022-03-25 19:41:33.116
!MESSAGE Breakpoint does not have an associated marker.

!ENTRY org.eclipse.jdt.debug 4 125 2022-03-25 19:41:33.117
!MESSAGE Internal error logged from JDI Debug: 
!STACK 1
org.eclipse.debug.core.DebugException: Breakpoint does not have an associated marker.
	at org.eclipse.debug.core.model.Breakpoint.ensureMarker(Breakpoint.java:297)
	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.getTypeName(JavaBreakpoint.java:926)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.lambda$1(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsResource(JDIDebugTarget.java:1431)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsBreakpoint(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.breakpointRemoved(JDIDebugTarget.java:1672)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.run(BreakpointManager.java:1030)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointNotifier.notify(BreakpointManager.java:1054)
	at org.eclipse.debug.internal.core.BreakpointManager.fireUpdate(BreakpointManager.java:962)
	at org.eclipse.debug.internal.core.BreakpointManager.removeBreakpoints(BreakpointManager.java:509)
	at org.eclipse.debug.internal.core.BreakpointManager$BreakpointManagerVisitor.update(BreakpointManager.java:758)
	at org.eclipse.debug.internal.core.BreakpointManager.resourceChanged(BreakpointManager.java:695)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:305)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:295)
	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:158)
	at org.eclipse.core.internal.resources.Workspace.broadcastBuildEvent(Workspace.java:367)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:164)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.debug.core 4 5012 2022-03-25 19:41:33.118
!MESSAGE Breakpoint does not have an associated marker.

!ENTRY org.eclipse.jface 4 2 2022-03-25 19:48:43.663
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jface".
!STACK 0
java.lang.ClassCastException: class org.eclipse.core.internal.resources.Folder cannot be cast to class org.eclipse.core.resources.IProject (org.eclipse.core.internal.resources.Folder and org.eclipse.core.resources.IProject are in unnamed module of loader org.eclipse.osgi.internal.loader.EquinoxClassLoader @25d93198)
	at org.eclipse.jdt.internal.ui.preferences.PropertyAndPreferencePage.setElement(PropertyAndPreferencePage.java:327)
	at org.eclipse.jdt.internal.ui.preferences.CompliancePreferencePage.setElement(CompliancePreferencePage.java:168)
	at org.eclipse.ui.internal.dialogs.RegistryPageContributor.createPage(RegistryPageContributor.java:145)
	at org.eclipse.ui.internal.dialogs.PropertyPageNode.createPage(PropertyPageNode.java:60)
	at org.eclipse.jface.preference.PreferenceDialog.createPage(PreferenceDialog.java:1280)
	at org.eclipse.ui.internal.dialogs.FilteredPreferenceDialog.createPage(FilteredPreferenceDialog.java:338)
	at org.eclipse.jface.preference.PreferenceDialog.showPage(PreferenceDialog.java:1166)
	at org.eclipse.ui.internal.dialogs.FilteredPreferenceDialog.showPage(FilteredPreferenceDialog.java:630)
	at org.eclipse.jface.preference.PreferenceDialog$5.lambda$0(PreferenceDialog.java:660)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jface.preference.PreferenceDialog$5.selectionChanged(PreferenceDialog.java:657)
	at org.eclipse.jface.viewers.StructuredViewer$3.run(StructuredViewer.java:821)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:174)
	at org.eclipse.jface.viewers.StructuredViewer.firePostSelectionChanged(StructuredViewer.java:818)
	at org.eclipse.jface.viewers.StructuredViewer.setSelection(StructuredViewer.java:1661)
	at org.eclipse.jface.viewers.TreeViewer.setSelection(TreeViewer.java:1090)
	at org.eclipse.jface.preference.PreferenceDialog.selectSavedItem(PreferenceDialog.java:990)
	at org.eclipse.ui.internal.dialogs.FilteredPreferenceDialog.selectSavedItem(FilteredPreferenceDialog.java:680)
	at org.eclipse.jface.preference.PreferenceDialog.lambda$0(PreferenceDialog.java:348)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jface.preference.PreferenceDialog.createContents(PreferenceDialog.java:345)
	at org.eclipse.jface.window.Window.create(Window.java:431)
	at org.eclipse.jface.dialogs.Dialog.create(Dialog.java:1094)
	at org.eclipse.ui.internal.dialogs.PropertyDialog.createDialogOn(PropertyDialog.java:84)
	at org.eclipse.ui.dialogs.PropertyDialogAction.createDialog(PropertyDialogAction.java:169)
	at org.eclipse.ui.dialogs.PropertyDialogAction.run(PropertyDialogAction.java:151)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4243)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1063)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4060)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3632)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)

!ENTRY org.eclipse.jface 4 2 2022-03-25 19:48:47.370
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jface".
!STACK 0
java.lang.ClassCastException: class org.eclipse.core.internal.resources.Folder cannot be cast to class org.eclipse.core.resources.IProject (org.eclipse.core.internal.resources.Folder and org.eclipse.core.resources.IProject are in unnamed module of loader org.eclipse.osgi.internal.loader.EquinoxClassLoader @25d93198)
	at org.eclipse.jdt.internal.ui.preferences.PropertyAndPreferencePage.setElement(PropertyAndPreferencePage.java:327)
	at org.eclipse.ui.internal.dialogs.RegistryPageContributor.createPage(RegistryPageContributor.java:145)
	at org.eclipse.ui.internal.dialogs.PropertyPageNode.createPage(PropertyPageNode.java:60)
	at org.eclipse.jface.preference.PreferenceDialog.createPage(PreferenceDialog.java:1280)
	at org.eclipse.ui.internal.dialogs.FilteredPreferenceDialog.createPage(FilteredPreferenceDialog.java:338)
	at org.eclipse.jface.preference.PreferenceDialog.showPage(PreferenceDialog.java:1166)
	at org.eclipse.ui.internal.dialogs.FilteredPreferenceDialog.showPage(FilteredPreferenceDialog.java:630)
	at org.eclipse.jface.preference.PreferenceDialog$5.lambda$0(PreferenceDialog.java:660)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jface.preference.PreferenceDialog$5.selectionChanged(PreferenceDialog.java:657)
	at org.eclipse.jface.viewers.StructuredViewer$3.run(StructuredViewer.java:821)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:174)
	at org.eclipse.jface.viewers.StructuredViewer.firePostSelectionChanged(StructuredViewer.java:818)
	at org.eclipse.jface.viewers.StructuredViewer.handlePostSelect(StructuredViewer.java:1191)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.jface.util.OpenStrategy.firePostSelectionEvent(OpenStrategy.java:284)
	at org.eclipse.jface.util.OpenStrategy$1.lambda$1(OpenStrategy.java:438)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.ui.dialogs.PropertyDialogAction.run(PropertyDialogAction.java:153)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4243)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1063)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4060)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3632)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2022-03-25 19:52:01.311
!MESSAGE Disconnected before saving. Please post stacktrace to https://bugs.eclipse.org/bugs/show_bug.cgi?id=569286 org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor SwapValores.java
!STACK 0
java.lang.IllegalStateException: Disconnected before saving. Please post stacktrace to https://bugs.eclipse.org/bugs/show_bug.cgi?id=569286 org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor SwapValores.java
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.disconnectEditor(AbstractTextEditor.java:7125)
	at org.eclipse.ui.texteditor.AbstractTextEditor.dispose(AbstractTextEditor.java:4323)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.dispose(AbstractDecoratedTextEditor.java:392)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.dispose(JavaEditor.java:2666)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.dispose(CompilationUnitEditor.java:1513)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.invalidate(CompatibilityPart.java:264)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.destroy(CompatibilityPart.java:421)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:960)
	at org.eclipse.e4.core.internal.di.InjectorImpl.uninject(InjectorImpl.java:201)
	at org.eclipse.e4.core.internal.di.Requestor.uninject(Requestor.java:177)
	at org.eclipse.e4.core.internal.contexts.ContextObjectSupplier$ContextInjectionListener.update(ContextObjectSupplier.java:89)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:103)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.removeListenersTo(EclipseContext.java:485)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.uninject(ContextInjectionFactory.java:184)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:947)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.subscribeTopicToBeRendered(PartRenderingEngine.java:185)
	at jdk.internal.reflect.GeneratedMethodAccessor71.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.di.internal.extensions.EventObjectSupplier$DIEventHandler.handleEvent(EventObjectSupplier.java:92)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setToBeRendered(UIElementImpl.java:314)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1401)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1331)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.closePart(StackRenderer.java:1182)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer$3.close(StackRenderer.java:1042)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1961)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:336)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4243)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1063)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4060)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3632)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)
	Suppressed: java.lang.IllegalStateException: isDirty check after disconnect
		at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7174)
		at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
		at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
		at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
		at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
		at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
		at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
		at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
		at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
		at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
		at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
		at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
		at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
		at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
		at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
		... 22 more
!SESSION 2022-03-25 21:54:41.205 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-25 21:54:47.691
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-25 21:54:47.691
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2b974137,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7402c49f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-25 21:54:47.691
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5d22604e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2382b2f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-25 21:54:51.313
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-27 19:56:38.550 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-27 19:58:16.264
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-27 19:58:16.264
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@54997f67,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@bf4e48e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-27 19:58:16.264
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@299eca90,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@189633f2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-27 19:58:20.366
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2022-03-27 22:35:33.214
!MESSAGE Disconnected before saving. Please post stacktrace to https://bugs.eclipse.org/bugs/show_bug.cgi?id=569286 org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor Multiplos.java
!STACK 0
java.lang.IllegalStateException: Disconnected before saving. Please post stacktrace to https://bugs.eclipse.org/bugs/show_bug.cgi?id=569286 org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor Multiplos.java
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.disconnectEditor(AbstractTextEditor.java:7125)
	at org.eclipse.ui.texteditor.AbstractTextEditor.dispose(AbstractTextEditor.java:4323)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.dispose(AbstractDecoratedTextEditor.java:392)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.dispose(JavaEditor.java:2666)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.dispose(CompilationUnitEditor.java:1513)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.invalidate(CompatibilityPart.java:264)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.destroy(CompatibilityPart.java:421)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:960)
	at org.eclipse.e4.core.internal.di.InjectorImpl.uninject(InjectorImpl.java:201)
	at org.eclipse.e4.core.internal.di.Requestor.uninject(Requestor.java:177)
	at org.eclipse.e4.core.internal.contexts.ContextObjectSupplier$ContextInjectionListener.update(ContextObjectSupplier.java:89)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:103)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.removeListenersTo(EclipseContext.java:485)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.uninject(ContextInjectionFactory.java:184)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:947)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.subscribeTopicToBeRendered(PartRenderingEngine.java:185)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.di.internal.extensions.EventObjectSupplier$DIEventHandler.handleEvent(EventObjectSupplier.java:92)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setToBeRendered(UIElementImpl.java:314)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1401)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1331)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.closePart(StackRenderer.java:1182)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer$3.close(StackRenderer.java:1042)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1961)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:336)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4243)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1063)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4060)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3632)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)
	Suppressed: java.lang.IllegalStateException: isDirty check after disconnect
		at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7174)
		at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
		at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
		at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
		at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
		at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
		at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
		at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
		at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
		at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
		at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
		at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
		at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
		at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
		at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
		... 22 more

!ENTRY org.eclipse.jdt.debug.ui 4 150 2022-03-27 22:40:41.733
!MESSAGE Internal Error
!STACK 1
org.eclipse.debug.core.DebugException: Invalid stack frame
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingStackFrame(JDIStackFrame.java:1371)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingThisObject(JDIStackFrame.java:1006)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getThis(JDIStackFrame.java:1425)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.lambda$3(JavaDebugHover.java:651)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.findFirstFrameForVariable(JavaDebugHover.java:604)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:388)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SUBENTRY 1 org.eclipse.jdt.debug 4 100 2022-03-27 22:40:41.734
!MESSAGE Invalid stack frame

!ENTRY org.eclipse.jdt.debug 4 125 2022-03-27 22:40:41.735
!MESSAGE Internal error logged from JDI Debug: 
!STACK 1
org.eclipse.debug.core.DebugException: Invalid stack frame
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingStackFrame(JDIStackFrame.java:1371)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingThisObject(JDIStackFrame.java:1006)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getThis(JDIStackFrame.java:1425)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.evaluateField(JavaDebugHover.java:528)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:388)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SUBENTRY 1 org.eclipse.jdt.debug 4 100 2022-03-27 22:40:41.735
!MESSAGE Invalid stack frame

!ENTRY org.eclipse.jdt.debug.ui 4 150 2022-03-27 22:40:44.404
!MESSAGE Internal Error
!STACK 1
org.eclipse.debug.core.DebugException: Invalid stack frame
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingStackFrame(JDIStackFrame.java:1371)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingThisObject(JDIStackFrame.java:1006)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getThis(JDIStackFrame.java:1425)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.lambda$3(JavaDebugHover.java:651)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.findFirstFrameForVariable(JavaDebugHover.java:604)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:388)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SUBENTRY 1 org.eclipse.jdt.debug 4 100 2022-03-27 22:40:44.404
!MESSAGE Invalid stack frame

!ENTRY org.eclipse.jdt.debug 4 125 2022-03-27 22:40:44.406
!MESSAGE Internal error logged from JDI Debug: 
!STACK 1
org.eclipse.debug.core.DebugException: Invalid stack frame
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingStackFrame(JDIStackFrame.java:1371)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingThisObject(JDIStackFrame.java:1006)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getThis(JDIStackFrame.java:1425)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.evaluateField(JavaDebugHover.java:528)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:388)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SUBENTRY 1 org.eclipse.jdt.debug 4 100 2022-03-27 22:40:44.406
!MESSAGE Invalid stack frame

!ENTRY org.eclipse.e4.ui.workbench 4 0 2022-03-27 23:55:28.050
!MESSAGE Execution exception for: ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.format,Format,
		Format the selected text,
		Category(org.eclipse.jdt.ui.category.source,Source,Java Source Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@33a6aebe,
		,,true),null) in 
	context chain: WorkbenchContext -> TrimmedWindowImpl (IDEWindow) Context -> PerspectiveImpl (org.eclipse.jdt.ui.JavaPerspective) Context -> PartImpl (org.eclipse.e4.ui.compatibility.editor)  removeOnHide org.eclipse.jdt.ui.CompilationUnitEditorContext
!STACK 0
org.eclipse.core.commands.ExecutionException: While executing the action, an exception occurred
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:126)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor64.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1280)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1062)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1087)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1072)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1114)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1110)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1539)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4868)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4746)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5015)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3630)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)
Caused by: java.lang.IndexOutOfBoundsException: Index -1 out of bounds for length 99
	at java.base/jdk.internal.util.Preconditions.outOfBounds(Preconditions.java:64)
	at java.base/jdk.internal.util.Preconditions.outOfBoundsCheckIndex(Preconditions.java:70)
	at java.base/jdk.internal.util.Preconditions.checkIndex(Preconditions.java:266)
	at java.base/java.util.Objects.checkIndex(Objects.java:359)
	at java.base/java.util.ArrayList.get(ArrayList.java:427)
	at org.eclipse.jdt.internal.formatter.TokenManager.get(TokenManager.java:76)
	at org.eclipse.jdt.internal.formatter.TokenManager.findIndex(TokenManager.java:169)
	at org.eclipse.jdt.internal.formatter.TokenManager.lastIndexIn(TokenManager.java:195)
	at org.eclipse.jdt.internal.formatter.LineBreaksPreparator.handleBracedCode(LineBreaksPreparator.java:713)
	at org.eclipse.jdt.internal.formatter.LineBreaksPreparator.handleBracedCode(LineBreaksPreparator.java:705)
	at org.eclipse.jdt.internal.formatter.LineBreaksPreparator.visit(LineBreaksPreparator.java:155)
	at org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:482)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:3129)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:3200)
	at org.eclipse.jdt.core.dom.CompilationUnit.accept0(CompilationUnit.java:258)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:3129)
	at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.prepareLineBreaks(DefaultCodeFormatter.java:415)
	at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.prepareFormattedCode(DefaultCodeFormatter.java:227)
	at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.format(DefaultCodeFormatter.java:183)
	at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.format(DefaultCodeFormatter.java:165)
	at org.eclipse.jdt.internal.corext.util.CodeFormatterUtil.reformat(CodeFormatterUtil.java:361)
	at org.eclipse.jdt.internal.ui.text.java.JavaFormattingStrategy.format(JavaFormattingStrategy.java:75)
	at org.eclipse.jface.text.formatter.MultiPassContentFormatter.formatMaster(MultiPassContentFormatter.java:197)
	at org.eclipse.jface.text.formatter.MultiPassContentFormatter.format(MultiPassContentFormatter.java:143)
	at org.eclipse.jface.text.source.SourceViewer.doOperation(SourceViewer.java:1025)
	at org.eclipse.jface.text.source.projection.ProjectionViewer.doOperation(ProjectionViewer.java:1466)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaSourceViewer.doOperation(JavaSourceViewer.java:179)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor$AdaptedSourceViewer.doOperation(CompilationUnitEditor.java:206)
	at org.eclipse.ui.texteditor.TextOperationAction.lambda$0(TextOperationAction.java:130)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.texteditor.TextOperationAction.run(TextOperationAction.java:130)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	... 54 more

!ENTRY org.eclipse.e4.ui.workbench 4 0 2022-03-27 23:55:29.970
!MESSAGE Execution exception for: ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.format,Format,
		Format the selected text,
		Category(org.eclipse.jdt.ui.category.source,Source,Java Source Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@33a6aebe,
		,,true),null) in 
	context chain: WorkbenchContext -> TrimmedWindowImpl (IDEWindow) Context -> PerspectiveImpl (org.eclipse.jdt.ui.JavaPerspective) Context -> PartImpl (org.eclipse.e4.ui.compatibility.editor)  removeOnHide org.eclipse.jdt.ui.CompilationUnitEditorContext
!STACK 0
org.eclipse.core.commands.ExecutionException: While executing the action, an exception occurred
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:126)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor64.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1280)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1062)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1087)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1072)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1114)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1110)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1539)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4868)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4746)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5015)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3630)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)
Caused by: java.lang.IndexOutOfBoundsException: Index -1 out of bounds for length 99
	at java.base/jdk.internal.util.Preconditions.outOfBounds(Preconditions.java:64)
	at java.base/jdk.internal.util.Preconditions.outOfBoundsCheckIndex(Preconditions.java:70)
	at java.base/jdk.internal.util.Preconditions.checkIndex(Preconditions.java:266)
	at java.base/java.util.Objects.checkIndex(Objects.java:359)
	at java.base/java.util.ArrayList.get(ArrayList.java:427)
	at org.eclipse.jdt.internal.formatter.TokenManager.get(TokenManager.java:76)
	at org.eclipse.jdt.internal.formatter.TokenManager.findIndex(TokenManager.java:169)
	at org.eclipse.jdt.internal.formatter.TokenManager.lastIndexIn(TokenManager.java:195)
	at org.eclipse.jdt.internal.formatter.LineBreaksPreparator.handleBracedCode(LineBreaksPreparator.java:713)
	at org.eclipse.jdt.internal.formatter.LineBreaksPreparator.handleBracedCode(LineBreaksPreparator.java:705)
	at org.eclipse.jdt.internal.formatter.LineBreaksPreparator.visit(LineBreaksPreparator.java:155)
	at org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:482)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:3129)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:3200)
	at org.eclipse.jdt.core.dom.CompilationUnit.accept0(CompilationUnit.java:258)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:3129)
	at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.prepareLineBreaks(DefaultCodeFormatter.java:415)
	at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.prepareFormattedCode(DefaultCodeFormatter.java:227)
	at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.format(DefaultCodeFormatter.java:183)
	at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.format(DefaultCodeFormatter.java:165)
	at org.eclipse.jdt.internal.corext.util.CodeFormatterUtil.reformat(CodeFormatterUtil.java:361)
	at org.eclipse.jdt.internal.ui.text.java.JavaFormattingStrategy.format(JavaFormattingStrategy.java:75)
	at org.eclipse.jface.text.formatter.MultiPassContentFormatter.formatMaster(MultiPassContentFormatter.java:197)
	at org.eclipse.jface.text.formatter.MultiPassContentFormatter.format(MultiPassContentFormatter.java:143)
	at org.eclipse.jface.text.source.SourceViewer.doOperation(SourceViewer.java:1025)
	at org.eclipse.jface.text.source.projection.ProjectionViewer.doOperation(ProjectionViewer.java:1466)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaSourceViewer.doOperation(JavaSourceViewer.java:179)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor$AdaptedSourceViewer.doOperation(CompilationUnitEditor.java:206)
	at org.eclipse.ui.texteditor.TextOperationAction.lambda$0(TextOperationAction.java:130)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.texteditor.TextOperationAction.run(TextOperationAction.java:130)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	... 54 more
!SESSION 2022-03-29 19:05:04.901 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2022-03-29 19:05:49.068
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2022-03-29 19:05:51.631
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-29 19:05:51.631
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4119346d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@61d09475,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-29 19:05:51.631
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@d0fabc8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@12d44a2a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-29 19:05:55.871
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2022-03-29 20:11:15.444
!MESSAGE Disconnected before saving. Please post stacktrace to https://bugs.eclipse.org/bugs/show_bug.cgi?id=569286 org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor TestAnimal3.java
!STACK 0
java.lang.IllegalStateException: Disconnected before saving. Please post stacktrace to https://bugs.eclipse.org/bugs/show_bug.cgi?id=569286 org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor TestAnimal3.java
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.disconnectEditor(AbstractTextEditor.java:7125)
	at org.eclipse.ui.texteditor.AbstractTextEditor.dispose(AbstractTextEditor.java:4323)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.dispose(AbstractDecoratedTextEditor.java:392)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.dispose(JavaEditor.java:2666)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.dispose(CompilationUnitEditor.java:1513)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.invalidate(CompatibilityPart.java:264)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.destroy(CompatibilityPart.java:421)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:960)
	at org.eclipse.e4.core.internal.di.InjectorImpl.uninject(InjectorImpl.java:201)
	at org.eclipse.e4.core.internal.di.Requestor.uninject(Requestor.java:177)
	at org.eclipse.e4.core.internal.contexts.ContextObjectSupplier$ContextInjectionListener.update(ContextObjectSupplier.java:89)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:103)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.removeListenersTo(EclipseContext.java:485)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.uninject(ContextInjectionFactory.java:184)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:947)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.subscribeTopicToBeRendered(PartRenderingEngine.java:185)
	at jdk.internal.reflect.GeneratedMethodAccessor68.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.di.internal.extensions.EventObjectSupplier$DIEventHandler.handleEvent(EventObjectSupplier.java:92)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setToBeRendered(UIElementImpl.java:314)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1401)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1331)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.closePart(StackRenderer.java:1182)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer$3.close(StackRenderer.java:1042)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1961)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:336)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4243)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1063)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4060)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3632)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)
	Suppressed: java.lang.IllegalStateException: isDirty check after disconnect
		at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7174)
		at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
		at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
		at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
		at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
		at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
		at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
		at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
		at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
		at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
		at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
		at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
		at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
		at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
		at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
		... 22 more
!SESSION 2022-03-29 20:19:12.858 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-29 20:19:18.723
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-29 20:19:18.723
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5d22604e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2382b2f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-29 20:19:18.723
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@13374ca6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@71734463,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-29 20:19:21.233
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-30 20:13:45.926 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-30 20:13:52.820
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-30 20:13:52.820
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@71734463,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3f1d6a13,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-30 20:13:52.820
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7cbf4f8c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@55c46ec1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-30 20:13:57.426
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-31 19:01:39.432 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-31 19:01:46.765
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-31 19:01:46.766
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@55c46ec1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3eff6846,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-31 19:01:46.766
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6ae6d078,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6ca33187,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-31 19:01:49.758
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-04-01 18:41:38.534 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-01 18:46:34.047
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-01 18:46:34.047
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3f1d6a13,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7cbf4f8c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-01 18:46:34.047
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@55c46ec1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3eff6846,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-01 18:46:36.645
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-04-02 23:42:53.999 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-02 23:43:00.822
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-02 23:43:00.823
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@71734463,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3f1d6a13,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-02 23:43:00.823
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7cbf4f8c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@55c46ec1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-02 23:43:05.068
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui.ide 4 4 2022-04-03 00:37:48.269
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Font.<init>(Font.java:111)
	at org.eclipse.buildship.ui.internal.util.font.FontUtils.getDefaultDialogFont(FontUtils.java:34)
	at org.eclipse.buildship.ui.internal.util.widget.GradleDistributionGroup.createWidgets(GradleDistributionGroup.java:95)
	at org.eclipse.buildship.ui.internal.util.widget.GradleDistributionGroup.<init>(GradleDistributionGroup.java:86)
	at org.eclipse.buildship.ui.internal.util.widget.GradleProjectSettingsComposite.createGradleDistributionGroup(GradleProjectSettingsComposite.java:100)
	at org.eclipse.buildship.ui.internal.util.widget.GradleProjectSettingsComposite.<init>(GradleProjectSettingsComposite.java:66)
	at org.eclipse.buildship.ui.internal.util.widget.GradleProjectSettingsComposite.<init>(GradleProjectSettingsComposite.java:38)
	at org.eclipse.buildship.ui.internal.util.widget.GradleProjectSettingsComposite$GradleProjectSettingsCompositeBuilder.build(GradleProjectSettingsComposite.java:253)
	at org.eclipse.buildship.ui.internal.preferences.GradleWorkbenchPreferencePage.createContents(GradleWorkbenchPreferencePage.java:61)
	at org.eclipse.jface.preference.PreferencePage.createControl(PreferencePage.java:244)
	at org.eclipse.jface.preference.PreferenceDialog.createPageControl(PreferenceDialog.java:1433)
	at org.eclipse.jface.preference.PreferenceDialog$8.run(PreferenceDialog.java:1196)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:174)
	at org.eclipse.jface.preference.PreferenceDialog.showPage(PreferenceDialog.java:1188)
	at org.eclipse.ui.internal.dialogs.FilteredPreferenceDialog.showPage(FilteredPreferenceDialog.java:630)
	at org.eclipse.jface.preference.PreferenceDialog$5.lambda$0(PreferenceDialog.java:660)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jface.preference.PreferenceDialog$5.selectionChanged(PreferenceDialog.java:657)
	at org.eclipse.jface.viewers.StructuredViewer$3.run(StructuredViewer.java:821)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:174)
	at org.eclipse.jface.viewers.StructuredViewer.firePostSelectionChanged(StructuredViewer.java:818)
	at org.eclipse.jface.viewers.StructuredViewer.handlePostSelect(StructuredViewer.java:1191)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.jface.util.OpenStrategy.firePostSelectionEvent(OpenStrategy.java:284)
	at org.eclipse.jface.util.OpenStrategy$1.lambda$1(OpenStrategy.java:438)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.ui.internal.OpenPreferencesAction.run(OpenPreferencesAction.java:66)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4243)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1063)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4060)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3632)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)

!ENTRY org.eclipse.ui.ide 4 4 2022-04-03 00:37:48.270
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Font.<init>(Font.java:111)
	at org.eclipse.buildship.ui.internal.util.font.FontUtils.getDefaultDialogFont(FontUtils.java:34)
	at org.eclipse.buildship.ui.internal.util.widget.AdvancedOptionsGroup.<init>(AdvancedOptionsGroup.java:59)
	at org.eclipse.buildship.ui.internal.util.widget.GradleProjectSettingsComposite.createAdvancedOptionsGroup(GradleProjectSettingsComposite.java:105)
	at org.eclipse.buildship.ui.internal.util.widget.GradleProjectSettingsComposite.<init>(GradleProjectSettingsComposite.java:67)
	at org.eclipse.buildship.ui.internal.util.widget.GradleProjectSettingsComposite.<init>(GradleProjectSettingsComposite.java:38)
	at org.eclipse.buildship.ui.internal.util.widget.GradleProjectSettingsComposite$GradleProjectSettingsCompositeBuilder.build(GradleProjectSettingsComposite.java:253)
	at org.eclipse.buildship.ui.internal.preferences.GradleWorkbenchPreferencePage.createContents(GradleWorkbenchPreferencePage.java:61)
	at org.eclipse.jface.preference.PreferencePage.createControl(PreferencePage.java:244)
	at org.eclipse.jface.preference.PreferenceDialog.createPageControl(PreferenceDialog.java:1433)
	at org.eclipse.jface.preference.PreferenceDialog$8.run(PreferenceDialog.java:1196)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:174)
	at org.eclipse.jface.preference.PreferenceDialog.showPage(PreferenceDialog.java:1188)
	at org.eclipse.ui.internal.dialogs.FilteredPreferenceDialog.showPage(FilteredPreferenceDialog.java:630)
	at org.eclipse.jface.preference.PreferenceDialog$5.lambda$0(PreferenceDialog.java:660)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jface.preference.PreferenceDialog$5.selectionChanged(PreferenceDialog.java:657)
	at org.eclipse.jface.viewers.StructuredViewer$3.run(StructuredViewer.java:821)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:174)
	at org.eclipse.jface.viewers.StructuredViewer.firePostSelectionChanged(StructuredViewer.java:818)
	at org.eclipse.jface.viewers.StructuredViewer.handlePostSelect(StructuredViewer.java:1191)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.jface.util.OpenStrategy.firePostSelectionEvent(OpenStrategy.java:284)
	at org.eclipse.jface.util.OpenStrategy$1.lambda$1(OpenStrategy.java:438)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.ui.internal.OpenPreferencesAction.run(OpenPreferencesAction.java:66)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4243)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1063)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4060)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3632)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)
!SESSION 2022-04-03 00:40:41.677 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-03 00:40:48.771
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-03 00:40:48.771
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5b5b9521,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@41f7c02d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-03 00:40:48.771
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@66314fee,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@14b5325f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-03 00:40:52.424
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2022-04-03 16:38:03.428
!MESSAGE Disconnected before saving. Please post stacktrace to https://bugs.eclipse.org/bugs/show_bug.cgi?id=569286 org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor ListaDeEnterosEnlazada.java
!STACK 0
java.lang.IllegalStateException: Disconnected before saving. Please post stacktrace to https://bugs.eclipse.org/bugs/show_bug.cgi?id=569286 org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor ListaDeEnterosEnlazada.java
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.disconnectEditor(AbstractTextEditor.java:7125)
	at org.eclipse.ui.texteditor.AbstractTextEditor.dispose(AbstractTextEditor.java:4323)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.dispose(AbstractDecoratedTextEditor.java:392)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.dispose(JavaEditor.java:2666)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.dispose(CompilationUnitEditor.java:1513)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.invalidate(CompatibilityPart.java:264)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.destroy(CompatibilityPart.java:421)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:960)
	at org.eclipse.e4.core.internal.di.InjectorImpl.uninject(InjectorImpl.java:201)
	at org.eclipse.e4.core.internal.di.Requestor.uninject(Requestor.java:177)
	at org.eclipse.e4.core.internal.contexts.ContextObjectSupplier$ContextInjectionListener.update(ContextObjectSupplier.java:89)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:103)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.removeListenersTo(EclipseContext.java:485)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.uninject(ContextInjectionFactory.java:184)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:947)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.subscribeTopicToBeRendered(PartRenderingEngine.java:185)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.di.internal.extensions.EventObjectSupplier$DIEventHandler.handleEvent(EventObjectSupplier.java:92)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setToBeRendered(UIElementImpl.java:314)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1401)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1331)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.closePart(StackRenderer.java:1182)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer$3.close(StackRenderer.java:1042)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1961)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:336)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4243)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1063)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4060)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3632)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)
	Suppressed: java.lang.IllegalStateException: isDirty check after disconnect
		at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7174)
		at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
		at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
		at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
		at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
		at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
		at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
		at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
		at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
		at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
		at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
		at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
		at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
		at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
		at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
		... 22 more
!SESSION 2022-04-03 21:05:57.557 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-03 21:06:04.671
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-03 21:06:04.671
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@ab2009f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2a11ae0b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-03 21:06:04.671
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1e4d8770,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5b5b9521,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-03 21:06:08.467
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-04-05 18:09:29.460 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-05 18:09:59.131
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-05 18:09:59.131
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5b5b9521,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@41f7c02d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-05 18:09:59.131
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@66314fee,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@14b5325f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-05 18:10:04.241
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-04-05 22:52:10.207 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-05 22:52:18.336
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-05 22:52:18.336
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@41f7c02d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@66314fee,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-05 22:52:18.336
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@14b5325f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@13404f75,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-05 22:52:22.210
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-04-06 21:05:20.390 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-06 21:05:27.632
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-06 21:05:27.632
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@41f7c02d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@66314fee,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-06 21:05:27.632
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@14b5325f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@13404f75,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-06 21:05:31.425
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-04-07 19:41:46.466 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-07 19:41:54.486
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-07 19:41:54.486
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@ab2009f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2a11ae0b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-07 19:41:54.486
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1e4d8770,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5b5b9521,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-07 19:41:59.612
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-04-08 18:16:40.194 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-08 18:16:47.814
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-08 18:16:47.814
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6d4502ca,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@ab2009f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-08 18:16:47.814
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2a11ae0b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1e4d8770,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-08 18:16:52.951
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-04-09 15:28:58.696 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 4 567 2022-04-09 15:29:01.915
!MESSAGE Workspace restored, but some problems occurred.
!SUBENTRY 1 org.eclipse.core.resources 4 567 2022-04-09 15:29:01.915
!MESSAGE Could not read metadata for '.org.eclipse.egit.core.cmp'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/.org.eclipse.egit.core.cmp)[567]: java.lang.Exception: The project description file (.project) for '.org.eclipse.egit.core.cmp' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:868)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1555)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2482)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2233)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:475)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:813)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:805)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:762)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:484)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2022-04-09 15:29:01.915
!MESSAGE The project description file (.project) for '.org.eclipse.egit.core.cmp' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for '.org.eclipse.egit.core.cmp' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:868)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1555)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2482)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2233)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:475)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:813)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:805)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:762)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:484)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jface 2 0 2022-04-09 15:29:03.694
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-09 15:29:03.694
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@41f90b10,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@67593f7b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-09 15:29:03.694
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2773504f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@497921d0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-09 15:29:08.787
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2022-04-09 15:29:09.320
!MESSAGE Exception while reading last build state for: P/Animales
!STACK 1
org.eclipse.core.runtime.CoreException: Error reading last build state for project Animales
	at org.eclipse.jdt.internal.core.JavaModelManager.readStateTimed(JavaModelManager.java:4120)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4096)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2264)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:860)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:392)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:417)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:161)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.eclipse.core.runtime.CoreException: Failed to init ct.sym for C:\Program Files\Java\jdk-17.0.1\lib\jrt-fs.jar
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:79)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:157)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:419)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:306)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readStateTimed(JavaModelManager.java:4115)
	... 16 more
Caused by: java.io.FileNotFoundException: File C:\Program Files\Java\jdk-17.0.1\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1955)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:77)
	... 21 more
!SUBENTRY 1 org.eclipse.jdt.core 4 2 2022-04-09 15:29:09.320
!MESSAGE Error reading last build state for project Animales
!STACK 1
org.eclipse.core.runtime.CoreException: Failed to init ct.sym for C:\Program Files\Java\jdk-17.0.1\lib\jrt-fs.jar
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:79)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:157)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:419)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:306)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readStateTimed(JavaModelManager.java:4115)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4096)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2264)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:860)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:392)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:417)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:161)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.io.FileNotFoundException: File C:\Program Files\Java\jdk-17.0.1\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1955)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:77)
	... 21 more
!SUBENTRY 2 org.eclipse.jdt.core 4 0 2022-04-09 15:29:09.321
!MESSAGE Failed to init ct.sym for C:\Program Files\Java\jdk-17.0.1\lib\jrt-fs.jar
!STACK 0
java.io.FileNotFoundException: File C:\Program Files\Java\jdk-17.0.1\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1955)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:77)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:157)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:419)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:306)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readStateTimed(JavaModelManager.java:4115)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4096)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2264)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:860)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:392)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:417)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:161)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-09 15:29:09.430
!MESSAGE Exception while reading last build state for: P/DispositivosMoviles
!STACK 1
org.eclipse.core.runtime.CoreException: Error reading last build state for project DispositivosMoviles
	at org.eclipse.jdt.internal.core.JavaModelManager.readStateTimed(JavaModelManager.java:4120)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4096)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2264)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:860)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:392)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:417)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:161)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.eclipse.core.runtime.CoreException: Failed to init ct.sym for C:\Program Files\Java\jdk-17.0.1\lib\jrt-fs.jar
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:79)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:157)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:419)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:306)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readStateTimed(JavaModelManager.java:4115)
	... 16 more
Caused by: java.io.FileNotFoundException: File C:\Program Files\Java\jdk-17.0.1\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1955)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:77)
	... 21 more
!SUBENTRY 1 org.eclipse.jdt.core 4 2 2022-04-09 15:29:09.430
!MESSAGE Error reading last build state for project DispositivosMoviles
!STACK 1
org.eclipse.core.runtime.CoreException: Failed to init ct.sym for C:\Program Files\Java\jdk-17.0.1\lib\jrt-fs.jar
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:79)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:157)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:419)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:306)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readStateTimed(JavaModelManager.java:4115)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4096)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2264)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:860)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:392)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:417)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:161)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.io.FileNotFoundException: File C:\Program Files\Java\jdk-17.0.1\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1955)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:77)
	... 21 more
!SUBENTRY 2 org.eclipse.jdt.core 4 0 2022-04-09 15:29:09.431
!MESSAGE Failed to init ct.sym for C:\Program Files\Java\jdk-17.0.1\lib\jrt-fs.jar
!STACK 0
java.io.FileNotFoundException: File C:\Program Files\Java\jdk-17.0.1\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1955)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:77)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:157)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:419)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:306)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readStateTimed(JavaModelManager.java:4115)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4096)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2264)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:860)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:392)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:417)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:161)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-09 15:29:09.519
!MESSAGE Exception while reading last build state for: P/FigurasGeometricas
!STACK 1
org.eclipse.core.runtime.CoreException: Error reading last build state for project FigurasGeometricas
	at org.eclipse.jdt.internal.core.JavaModelManager.readStateTimed(JavaModelManager.java:4120)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4096)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2264)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:860)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:392)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:417)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:161)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.eclipse.core.runtime.CoreException: Failed to init ct.sym for C:\Program Files\Java\jdk-17.0.1\lib\jrt-fs.jar
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:79)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:157)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:419)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:306)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readStateTimed(JavaModelManager.java:4115)
	... 16 more
Caused by: java.io.FileNotFoundException: File C:\Program Files\Java\jdk-17.0.1\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1955)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:77)
	... 21 more
!SUBENTRY 1 org.eclipse.jdt.core 4 2 2022-04-09 15:29:09.519
!MESSAGE Error reading last build state for project FigurasGeometricas
!STACK 1
org.eclipse.core.runtime.CoreException: Failed to init ct.sym for C:\Program Files\Java\jdk-17.0.1\lib\jrt-fs.jar
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:79)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:157)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:419)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:306)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readStateTimed(JavaModelManager.java:4115)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4096)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2264)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:860)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:392)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:417)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:161)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.io.FileNotFoundException: File C:\Program Files\Java\jdk-17.0.1\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1955)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:77)
	... 21 more
!SUBENTRY 2 org.eclipse.jdt.core 4 0 2022-04-09 15:29:09.520
!MESSAGE Failed to init ct.sym for C:\Program Files\Java\jdk-17.0.1\lib\jrt-fs.jar
!STACK 0
java.io.FileNotFoundException: File C:\Program Files\Java\jdk-17.0.1\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1955)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:77)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:157)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:419)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:306)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readStateTimed(JavaModelManager.java:4115)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4096)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2264)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:860)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:392)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:417)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:161)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-09 15:29:09.840
!MESSAGE Exception while reading last build state for: P/Practica1
!STACK 1
org.eclipse.core.runtime.CoreException: Error reading last build state for project Practica1
	at org.eclipse.jdt.internal.core.JavaModelManager.readStateTimed(JavaModelManager.java:4120)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4096)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2264)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:860)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:392)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:417)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:161)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.internal.compiler.util.JrtFileSystem.walkModuleImage(org.eclipse.jdt.internal.compiler.util.JRTUtil$JrtFileVisitor, int)" because the return value of "org.eclipse.jdt.internal.compiler.util.JRTUtil.getJrtSystem(java.io.File, String)" is null
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.walkModuleImage(JRTUtil.java:173)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.loadModules(ClasspathJrt.java:126)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.<init>(ClasspathJrt.java:63)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:156)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:419)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:306)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readStateTimed(JavaModelManager.java:4115)
	... 16 more
!SUBENTRY 1 org.eclipse.jdt.core 4 2 2022-04-09 15:29:09.840
!MESSAGE Error reading last build state for project Practica1
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.internal.compiler.util.JrtFileSystem.walkModuleImage(org.eclipse.jdt.internal.compiler.util.JRTUtil$JrtFileVisitor, int)" because the return value of "org.eclipse.jdt.internal.compiler.util.JRTUtil.getJrtSystem(java.io.File, String)" is null
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.walkModuleImage(JRTUtil.java:173)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.loadModules(ClasspathJrt.java:126)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.<init>(ClasspathJrt.java:63)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:156)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:419)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:306)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readStateTimed(JavaModelManager.java:4115)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4096)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2264)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:860)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:392)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:417)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:161)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-09 15:29:09.892
!MESSAGE Exception while reading last build state for: P/Practica2
!STACK 1
org.eclipse.core.runtime.CoreException: Error reading last build state for project Practica2
	at org.eclipse.jdt.internal.core.JavaModelManager.readStateTimed(JavaModelManager.java:4120)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4096)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2264)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:860)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:392)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:417)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:161)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.eclipse.core.runtime.CoreException: Failed to init ct.sym for C:\Program Files\Java\jdk-17.0.1\lib\jrt-fs.jar
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:79)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:157)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:419)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:306)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readStateTimed(JavaModelManager.java:4115)
	... 16 more
Caused by: java.io.FileNotFoundException: File C:\Program Files\Java\jdk-17.0.1\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1955)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:77)
	... 21 more
!SUBENTRY 1 org.eclipse.jdt.core 4 2 2022-04-09 15:29:09.892
!MESSAGE Error reading last build state for project Practica2
!STACK 1
org.eclipse.core.runtime.CoreException: Failed to init ct.sym for C:\Program Files\Java\jdk-17.0.1\lib\jrt-fs.jar
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:79)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:157)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:419)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:306)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readStateTimed(JavaModelManager.java:4115)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4096)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2264)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:860)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:392)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:417)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:161)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.io.FileNotFoundException: File C:\Program Files\Java\jdk-17.0.1\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1955)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:77)
	... 21 more
!SUBENTRY 2 org.eclipse.jdt.core 4 0 2022-04-09 15:29:09.893
!MESSAGE Failed to init ct.sym for C:\Program Files\Java\jdk-17.0.1\lib\jrt-fs.jar
!STACK 0
java.io.FileNotFoundException: File C:\Program Files\Java\jdk-17.0.1\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1955)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:77)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:157)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:419)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:306)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readStateTimed(JavaModelManager.java:4115)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4096)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2264)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:860)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:392)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:417)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:161)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-09 15:29:09.968
!MESSAGE Exception while reading last build state for: P/Programacion3
!STACK 1
org.eclipse.core.runtime.CoreException: Error reading last build state for project Programacion3
	at org.eclipse.jdt.internal.core.JavaModelManager.readStateTimed(JavaModelManager.java:4120)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4096)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2264)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:860)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:392)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:417)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:161)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.internal.compiler.util.JrtFileSystem.walkModuleImage(org.eclipse.jdt.internal.compiler.util.JRTUtil$JrtFileVisitor, int)" because the return value of "org.eclipse.jdt.internal.compiler.util.JRTUtil.getJrtSystem(java.io.File, String)" is null
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.walkModuleImage(JRTUtil.java:173)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.loadModules(ClasspathJrt.java:126)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.<init>(ClasspathJrt.java:63)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:156)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:419)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:306)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readStateTimed(JavaModelManager.java:4115)
	... 16 more
!SUBENTRY 1 org.eclipse.jdt.core 4 2 2022-04-09 15:29:09.968
!MESSAGE Error reading last build state for project Programacion3
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.internal.compiler.util.JrtFileSystem.walkModuleImage(org.eclipse.jdt.internal.compiler.util.JRTUtil$JrtFileVisitor, int)" because the return value of "org.eclipse.jdt.internal.compiler.util.JRTUtil.getJrtSystem(java.io.File, String)" is null
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.walkModuleImage(JRTUtil.java:173)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.loadModules(ClasspathJrt.java:126)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.<init>(ClasspathJrt.java:63)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:156)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:419)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:306)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readStateTimed(JavaModelManager.java:4115)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4096)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2264)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:860)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:392)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:417)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:161)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.oomph.ui 4 0 2022-04-09 15:29:14.979
!MESSAGE java.lang.ExceptionInInitializerError
!STACK 0
java.lang.ExceptionInInitializerError
	at org.eclipse.oomph.setup.ui.recorder.RecorderManager.<clinit>(RecorderManager.java:121)
	at org.eclipse.oomph.setup.ui.SetupUIPlugin.performStartup(SetupUIPlugin.java:216)
	at org.eclipse.oomph.setup.ui.EarlyStartup.earlyStartup(EarlyStartup.java:23)
	at org.eclipse.oomph.internal.ui.EarlyStart.run(EarlyStart.java:119)
	at org.eclipse.oomph.internal.ui.EarlyStart$1.run(EarlyStart.java:98)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.lang.IllegalStateException: BundleContext is no longer valid org.eclipse.oomph.p2.core_1.21.0.v20220301-0958 [307]
	at org.eclipse.osgi.internal.framework.BundleContextImpl.checkValid(BundleContextImpl.java:1026)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.ungetService(BundleContextImpl.java:696)
	at org.eclipse.oomph.p2.internal.core.AgentManagerImpl.getCurrentAgent(AgentManagerImpl.java:194)
	at org.eclipse.oomph.p2.core.P2Util.getCurrentProvisioningAgent(P2Util.java:111)
	at org.eclipse.oomph.setup.internal.core.util.SetupCoreUtil.<clinit>(SetupCoreUtil.java:157)
	... 6 more
!SESSION 2022-04-09 16:06:19.347 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-09 16:06:26.853
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-09 16:06:26.853
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@26f480c6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2567c091,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-09 16:06:26.853
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7747cc1b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@76cf91c9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-09 16:06:30.311
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-04-09 17:04:46.353 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-09 17:04:53.284
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-09 17:04:53.284
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@775edae0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@26f480c6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-09 17:04:53.284
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2567c091,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7747cc1b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-09 17:04:56.705
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-04-10 17:58:07.051 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-10 17:58:13.581
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-10 17:58:13.581
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@12723c5d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@56a09a5c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-10 17:58:13.581
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@775edae0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@26f480c6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-10 17:58:16.960
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2022-04-11 00:36:43.167
!MESSAGE Disconnected before saving. Please post stacktrace to https://bugs.eclipse.org/bugs/show_bug.cgi?id=569286 org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor TestListaGenerica.java
!STACK 0
java.lang.IllegalStateException: Disconnected before saving. Please post stacktrace to https://bugs.eclipse.org/bugs/show_bug.cgi?id=569286 org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor TestListaGenerica.java
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.disconnectEditor(AbstractTextEditor.java:7125)
	at org.eclipse.ui.texteditor.AbstractTextEditor.dispose(AbstractTextEditor.java:4323)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.dispose(AbstractDecoratedTextEditor.java:392)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.dispose(JavaEditor.java:2666)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.dispose(CompilationUnitEditor.java:1513)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.invalidate(CompatibilityPart.java:264)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.destroy(CompatibilityPart.java:421)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:960)
	at org.eclipse.e4.core.internal.di.InjectorImpl.uninject(InjectorImpl.java:201)
	at org.eclipse.e4.core.internal.di.Requestor.uninject(Requestor.java:177)
	at org.eclipse.e4.core.internal.contexts.ContextObjectSupplier$ContextInjectionListener.update(ContextObjectSupplier.java:89)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:103)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.removeListenersTo(EclipseContext.java:485)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.uninject(ContextInjectionFactory.java:184)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:947)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.subscribeTopicToBeRendered(PartRenderingEngine.java:185)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.di.internal.extensions.EventObjectSupplier$DIEventHandler.handleEvent(EventObjectSupplier.java:92)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setToBeRendered(UIElementImpl.java:314)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1401)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1331)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.closePart(StackRenderer.java:1182)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer$3.close(StackRenderer.java:1042)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1961)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:336)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4243)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1063)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4060)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3632)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	Suppressed: java.lang.IllegalStateException: isDirty check after disconnect
		at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7174)
		at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
		at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
		at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
		at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
		at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
		at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
		at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
		at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
		at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
		at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
		at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
		at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
		at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
		at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
		... 21 more
!SESSION 2022-04-12 18:37:55.700 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-12 18:38:19.214
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-12 18:38:19.214
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@12723c5d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@56a09a5c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-12 18:38:19.214
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@775edae0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@26f480c6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-12 18:38:24.334
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-04-13 17:05:21.304 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-13 18:34:58.246
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-13 18:34:58.246
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@26f480c6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2567c091,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-13 18:34:58.246
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7747cc1b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@76cf91c9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-13 18:35:02.552
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui.ide 4 4 2022-04-14 01:43:57.076
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:683)
	at org.eclipse.jface.resource.URLImageDescriptor.createImage(URLImageDescriptor.java:275)
	at org.eclipse.jface.resource.ImageDescriptor.createResource(ImageDescriptor.java:230)
	at org.eclipse.jface.resource.DeviceResourceManager.allocate(DeviceResourceManager.java:55)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:88)
	at org.eclipse.jface.resource.LazyResourceManager.create(LazyResourceManager.java:103)
	at org.eclipse.jface.resource.LocalResourceManager.allocate(LocalResourceManager.java:72)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:88)
	at org.eclipse.jface.resource.ResourceManager.createImage(ResourceManager.java:175)
	at org.eclipse.e4.ui.workbench.renderers.swt.AbstractContributionItem.getImage(AbstractContributionItem.java:151)
	at org.eclipse.e4.ui.workbench.renderers.swt.AbstractContributionItem.updateIcons(AbstractContributionItem.java:177)
	at org.eclipse.e4.ui.workbench.renderers.swt.AbstractContributionItem.update(AbstractContributionItem.java:127)
	at org.eclipse.e4.ui.workbench.renderers.swt.AbstractContributionItem.fill(AbstractContributionItem.java:264)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1227)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeUIElementTopicVisible(MenuManagerRenderer.java:213)
	at jdk.internal.reflect.GeneratedMethodAccessor37.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4779)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setVisible(UIElementImpl.java:361)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.updateVisibility(ContributionRecord.java:105)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:191)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:202)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.showMenu(MenuManagerShowProcessor.java:256)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.menuAboutToHide(MenuManagerShowProcessor.java:114)
	at org.eclipse.jface.internal.MenuManagerEventHelper.showEventPostHelper(MenuManagerEventHelper.java:95)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:469)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4243)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1063)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1087)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1068)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5143)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4775)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2286)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5015)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4101)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui.ide 4 4 2022-04-14 01:43:57.089
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:683)
	at org.eclipse.jface.resource.URLImageDescriptor.createImage(URLImageDescriptor.java:275)
	at org.eclipse.jface.resource.ImageDescriptor.createResource(ImageDescriptor.java:230)
	at org.eclipse.jface.resource.DeviceResourceManager.allocate(DeviceResourceManager.java:55)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:88)
	at org.eclipse.jface.resource.LazyResourceManager.create(LazyResourceManager.java:103)
	at org.eclipse.jface.resource.LocalResourceManager.allocate(LocalResourceManager.java:72)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:88)
	at org.eclipse.jface.resource.ResourceManager.createImage(ResourceManager.java:175)
	at org.eclipse.e4.ui.workbench.renderers.swt.AbstractContributionItem.getImage(AbstractContributionItem.java:151)
	at org.eclipse.e4.ui.workbench.renderers.swt.AbstractContributionItem.updateIcons(AbstractContributionItem.java:177)
	at org.eclipse.e4.ui.workbench.renderers.swt.AbstractContributionItem.update(AbstractContributionItem.java:127)
	at org.eclipse.e4.ui.workbench.renderers.swt.AbstractContributionItem.fill(AbstractContributionItem.java:264)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1227)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeUIElementTopicVisible(MenuManagerRenderer.java:213)
	at jdk.internal.reflect.GeneratedMethodAccessor37.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4779)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setVisible(UIElementImpl.java:361)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.updateVisibility(ContributionRecord.java:105)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:191)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:202)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:202)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.showMenu(MenuManagerShowProcessor.java:256)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.menuAboutToHide(MenuManagerShowProcessor.java:114)
	at org.eclipse.jface.internal.MenuManagerEventHelper.showEventPostHelper(MenuManagerEventHelper.java:95)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:469)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4243)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1063)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1087)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1068)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5143)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4775)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2286)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5015)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4101)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui.ide 4 4 2022-04-14 01:43:57.090
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:683)
	at org.eclipse.jface.resource.URLImageDescriptor.createImage(URLImageDescriptor.java:275)
	at org.eclipse.jface.resource.ImageDescriptor.createResource(ImageDescriptor.java:230)
	at org.eclipse.jface.resource.DeviceResourceManager.allocate(DeviceResourceManager.java:55)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:88)
	at org.eclipse.jface.resource.LazyResourceManager.create(LazyResourceManager.java:103)
	at org.eclipse.jface.resource.LocalResourceManager.allocate(LocalResourceManager.java:72)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:88)
	at org.eclipse.jface.resource.ResourceManager.createImage(ResourceManager.java:175)
	at org.eclipse.e4.ui.workbench.renderers.swt.AbstractContributionItem.getImage(AbstractContributionItem.java:151)
	at org.eclipse.e4.ui.workbench.renderers.swt.AbstractContributionItem.updateIcons(AbstractContributionItem.java:177)
	at org.eclipse.e4.ui.workbench.renderers.swt.AbstractContributionItem.update(AbstractContributionItem.java:127)
	at org.eclipse.e4.ui.workbench.renderers.swt.AbstractContributionItem.fill(AbstractContributionItem.java:264)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1227)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeUIElementTopicVisible(MenuManagerRenderer.java:213)
	at jdk.internal.reflect.GeneratedMethodAccessor37.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4779)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setVisible(UIElementImpl.java:361)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.updateVisibility(ContributionRecord.java:105)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:191)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:202)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.showMenu(MenuManagerShowProcessor.java:256)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.menuAboutToHide(MenuManagerShowProcessor.java:114)
	at org.eclipse.jface.internal.MenuManagerEventHelper.showEventPostHelper(MenuManagerEventHelper.java:95)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:469)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4243)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1063)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1087)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1068)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5143)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4775)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2286)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5015)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4101)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SESSION 2022-04-15 00:17:09.286 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-15 00:17:27.984
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-15 00:17:27.984
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2567c091,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7747cc1b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-15 00:17:27.984
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@76cf91c9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@74bfdd66,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-15 00:17:31.585
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-04-16 11:51:05.260 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-16 11:51:19.017
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-16 11:51:19.017
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7747cc1b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@76cf91c9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-16 11:51:19.017
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@74bfdd66,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6fc7e828,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-16 11:51:23.145
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.oomph.ui 4 0 2022-04-16 11:51:28.657
!MESSAGE java.lang.ExceptionInInitializerError
!STACK 0
java.lang.ExceptionInInitializerError
	at org.eclipse.oomph.setup.ui.recorder.RecorderManager.<clinit>(RecorderManager.java:121)
	at org.eclipse.oomph.setup.ui.SetupUIPlugin.performStartup(SetupUIPlugin.java:216)
	at org.eclipse.oomph.setup.ui.EarlyStartup.earlyStartup(EarlyStartup.java:23)
	at org.eclipse.oomph.internal.ui.EarlyStart.run(EarlyStart.java:119)
	at org.eclipse.oomph.internal.ui.EarlyStart$1.run(EarlyStart.java:98)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.lang.NullPointerException: Cannot invoke "org.osgi.framework.BundleContext.getServiceReference(java.lang.Class)" because "context" is null
	at org.eclipse.oomph.p2.internal.core.AgentManagerImpl.getCurrentAgent(AgentManagerImpl.java:169)
	at org.eclipse.oomph.p2.core.P2Util.getCurrentProvisioningAgent(P2Util.java:111)
	at org.eclipse.oomph.setup.internal.core.util.SetupCoreUtil.<clinit>(SetupCoreUtil.java:157)
	... 6 more
!SESSION 2022-04-17 22:07:46.721 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-17 22:08:10.831
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-17 22:08:10.831
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a41caed,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6b4fd7d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-17 22:08:10.831
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7404aff2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@12723c5d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-17 22:08:15.507
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-04-18 15:11:31.694 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-18 15:12:20.087
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-18 15:12:20.087
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@77476fcf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@70805849,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-18 15:12:20.087
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@e7d0db2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a41caed,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-18 15:12:24.271
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-04-18 15:23:48.613 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-18 15:23:53.221
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-18 15:23:53.221
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@e895e3e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@77476fcf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-18 15:23:53.221
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@70805849,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@e7d0db2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-18 15:23:56.831
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-04-18 16:28:15.067 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-18 16:28:22.588
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-18 16:28:22.588
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2567c091,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7747cc1b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-18 16:28:22.588
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@76cf91c9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@74bfdd66,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-18 16:28:25.316
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-04-18 17:37:39.318 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-18 17:38:00.022
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-18 17:38:00.022
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2567c091,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7747cc1b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-18 17:38:00.022
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@76cf91c9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@74bfdd66,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-18 17:38:03.225
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-04-18 19:54:42.619 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-18 19:54:59.603
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-18 19:54:59.603
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@76cf91c9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@74bfdd66,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-18 19:54:59.603
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6fc7e828,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@26a9c6df,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-18 19:55:05.100
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-04-21 19:59:10.850 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-21 19:59:34.418
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-21 19:59:34.418
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@76cf91c9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@74bfdd66,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-21 19:59:34.418
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6fc7e828,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@26a9c6df,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-21 19:59:38.712
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-04-25 15:23:33.382 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-25 15:23:47.424
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-25 15:23:47.424
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7747cc1b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@76cf91c9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-25 15:23:47.424
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@74bfdd66,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6fc7e828,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-25 15:23:52.812
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-04-28 19:26:52.660 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-28 19:27:10.069
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-28 19:27:10.069
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7747cc1b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@76cf91c9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-28 19:27:10.069
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@74bfdd66,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6fc7e828,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-28 19:27:14.025
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-04-29 08:49:08.847 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-29 08:49:32.444
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-29 08:49:32.444
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@26f480c6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2567c091,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-29 08:49:32.444
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7747cc1b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@76cf91c9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-29 08:49:37.054
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-04-29 10:12:06.126 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-29 10:12:13.876
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-29 10:12:13.876
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a41caed,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6b4fd7d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-29 10:12:13.876
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7404aff2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@12723c5d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-29 10:12:17.464
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-04-29 12:23:42.525 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-29 12:23:51.149
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-29 12:23:51.149
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7747cc1b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@76cf91c9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-29 12:23:51.149
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@74bfdd66,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6fc7e828,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-29 12:23:55.443
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-04-29 17:42:15.110 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-29 17:42:36.940
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-29 17:42:36.940
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@76cf91c9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@74bfdd66,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-29 17:42:36.940
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6fc7e828,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@26a9c6df,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-29 17:42:45.383
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-04-30 09:55:37.945 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-30 09:55:55.356
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-30 09:55:55.356
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@540212be,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2579d8a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-30 09:55:55.356
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2507a170,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7e20f4e3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-30 09:55:59.011
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-04-30 18:15:39.179 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-30 18:15:49.387
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-30 18:15:49.387
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@26a9c6df,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2ce24a1a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-30 18:15:49.387
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@26bce60d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@76eadc5a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-30 18:15:54.748
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-04-30 18:52:31.664 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-30 18:52:35.916
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-30 18:52:35.916
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@26f480c6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2567c091,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-30 18:52:35.916
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7747cc1b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@76cf91c9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-30 18:52:38.862
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-04-30 19:04:44.287 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-30 19:04:48.620
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-30 19:04:48.620
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6fc7e828,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@26a9c6df,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-30 19:04:48.620
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2ce24a1a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@26bce60d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-30 19:04:51.644
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-04-30 19:25:35.978 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-30 19:25:40.053
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-30 19:25:40.053
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@76eadc5a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1e9d7366,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-30 19:25:40.053
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@20914835,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@615c4ea4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-30 19:25:43.083
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-04-30 22:15:24.274 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-04-30 22:15:29.596
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-30 22:15:29.596
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6fc7e828,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@26a9c6df,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-30 22:15:29.596
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2ce24a1a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@26bce60d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-30 22:15:33.418
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-05-01 14:46:08.105 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-05-01 14:46:29.476
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-05-01 14:46:29.476
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@76eadc5a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1e9d7366,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-05-01 14:46:29.476
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@20914835,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@615c4ea4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-05-01 14:46:36.994
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2022-05-01 16:22:51.169
!MESSAGE Disconnected before saving. Please post stacktrace to https://bugs.eclipse.org/bugs/show_bug.cgi?id=569286 org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor Expresion.java
!STACK 0
java.lang.IllegalStateException: Disconnected before saving. Please post stacktrace to https://bugs.eclipse.org/bugs/show_bug.cgi?id=569286 org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor Expresion.java
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.disconnectEditor(AbstractTextEditor.java:7125)
	at org.eclipse.ui.texteditor.AbstractTextEditor.dispose(AbstractTextEditor.java:4323)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.dispose(AbstractDecoratedTextEditor.java:392)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.dispose(JavaEditor.java:2666)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.dispose(CompilationUnitEditor.java:1513)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.invalidate(CompatibilityPart.java:264)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.destroy(CompatibilityPart.java:421)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:960)
	at org.eclipse.e4.core.internal.di.InjectorImpl.uninject(InjectorImpl.java:201)
	at org.eclipse.e4.core.internal.di.Requestor.uninject(Requestor.java:177)
	at org.eclipse.e4.core.internal.contexts.ContextObjectSupplier$ContextInjectionListener.update(ContextObjectSupplier.java:89)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:103)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.removeListenersTo(EclipseContext.java:485)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.uninject(ContextInjectionFactory.java:184)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:947)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.subscribeTopicToBeRendered(PartRenderingEngine.java:185)
	at jdk.internal.reflect.GeneratedMethodAccessor63.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.di.internal.extensions.EventObjectSupplier$DIEventHandler.handleEvent(EventObjectSupplier.java:92)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setToBeRendered(UIElementImpl.java:314)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1401)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1331)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.closePart(StackRenderer.java:1182)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer$3.close(StackRenderer.java:1042)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1961)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:336)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4243)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1063)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4060)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3632)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	Suppressed: java.lang.IllegalStateException: isDirty check after disconnect
		at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7174)
		at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
		at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
		at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
		at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
		at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
		at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
		at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
		at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
		at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
		at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
		at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
		at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
		at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
		at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
		... 21 more
!SESSION 2022-05-01 18:07:01.323 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-05-01 18:07:11.282
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-05-01 18:07:11.282
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2ce24a1a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@26bce60d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-05-01 18:07:11.282
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@76eadc5a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1e9d7366,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-05-01 18:07:14.580
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-05-02 12:35:52.674 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-05-02 12:37:16.460
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-05-02 12:37:16.460
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@74bfdd66,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6fc7e828,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-05-02 12:37:16.460
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@26a9c6df,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2ce24a1a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-05-02 12:37:20.457
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-05-02 19:21:50.258 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-05-02 19:21:56.562
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-05-02 19:21:56.562
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1e9d7366,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@20914835,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-05-02 19:21:56.562
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@615c4ea4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@417446d9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-05-02 19:21:59.848
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-05-20 10:08:08.910 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-05-20 10:08:35.989
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-05-20 10:08:35.989
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7404aff2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@12723c5d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-05-20 10:08:35.989
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@56a09a5c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@775edae0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-05-20 10:08:38.544
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-05-22 19:47:43.481 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-05-22 19:47:54.477
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-05-22 19:47:54.477
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1e9d7366,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@20914835,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-05-22 19:47:54.477
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@615c4ea4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@417446d9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-05-22 19:47:58.171
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-05-27 18:34:04.647 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-05-27 18:34:34.784
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-05-27 18:34:34.784
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@76cf91c9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@74bfdd66,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-05-27 18:34:34.784
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6fc7e828,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@26a9c6df,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-05-27 18:34:44.533
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-05-30 17:44:33.701 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-05-30 17:45:09.312
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-05-30 17:45:09.312
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@76eadc5a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1e9d7366,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-05-30 17:45:09.312
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@20914835,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@615c4ea4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-05-30 17:45:13.581
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-06-03 18:10:38.632 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-06-03 18:11:04.951
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-03 18:11:04.951
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1e9d7366,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@20914835,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-03 18:11:04.951
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@615c4ea4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@417446d9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-06-03 18:11:10.880
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-06-06 13:46:35.071 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-06-06 13:46:58.147
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-06 13:46:58.147
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6fc7e828,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@26a9c6df,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-06 13:46:58.147
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2ce24a1a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@26bce60d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-06-06 13:47:03.466
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-06-06 15:08:00.031 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-06-06 15:08:24.838
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-06 15:08:24.838
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@34070bd2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1e7d3d87,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-06 15:08:24.838
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1dd76982,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7e76a66f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-06-06 15:08:28.803
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-06-06 17:38:40.534 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-06-06 17:39:00.810
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-06 17:39:00.810
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@76eadc5a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1e9d7366,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-06 17:39:00.810
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@20914835,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@615c4ea4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-06-06 17:39:05.512
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2022-06-06 18:11:11.363
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package prog3.grafos.ejercicios;

import prog3.grafos.*;
import prog3.listagenerica.*;
import prog3.util.*;

public class Mapa {

	Grafo<String> mapaCiudades = new GrafoImplListAdy<String>();

	public Mapa(Grafo<String> mapaCiudades) {
		super();
		this.mapaCiudades = mapaCiudades;
	}

	/*
	 * El método devolverCamino (String ciudad1, String ciudad2):
	 * ListaGenerica<String> // Retorna la lista de ciudades que se deben atravesar
	 * para ir de ciudad1 a ciudad2 en caso que se pueda llegar, si no retorna la
	 * lista vacía. (Sin tener en cuenta el combustible).
	 */
	public ListaGenerica<String> devolverCamino(String ciudad1, String ciudad2) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.devolverCamino(i, mapaCiudades, res, ciudad2, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}
	private boolean devolverCamino(int i, Grafo<String> grafo, ListaGenerica<String> lis, String ciudad2,
			boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.devolverCamino(j, grafo, lis, ciudad2, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	
	/*
	 * El método devolverCaminoExceptuando (String ciudad1, String ciudad2,
	 * ListaGenerica<String> ciudades): ListaGenerica<String> // Retorna la lista de
	 * ciudades que forman un camino desde ciudad1 a ciudad2, sin pasar por las
	 * ciudades que están contenidas en la lista ciudades pasada por parámetro, si
	 * no existe camino retorna la lista vacía. (Sin tener en cuenta el
	 * combustible).
	 */
	public ListaGenerica<String> devolverCaminoExceptuando(String ciudad1, String ciudad2,
			ListaGenerica<String> ciudades) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.devolverCaminoExceptuando(i, mapaCiudades, res, ciudades, ciudad2, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}
	private boolean devolverCaminoExceptuando(int i, Grafo<String> grafo, ListaGenerica<String> lis,
			ListaGenerica<String> excepto, String ciudad2, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		excepto.comenzar();
		while (!excepto.fin()) {
			if (v.dato().equals(excepto.proximo())) {
				return false;
			}
		}
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.devolverCaminoExceptuando(j, grafo, lis, excepto, ciudad2, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				marca[i] = false;
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	
	/*
	 * El método caminoMasCorto(String ciudad1, String ciudad2):
	 * ListaGenerica<String> // Retorna la lista de ciudades que forman el camino
	 * más corto para llegar de ciudad1 a ciudad2, si no existe camino retorna la
	 * lista vacía. (Las rutas poseen la distancia). (Sin tener en cuenta el
	 * combustible).
	 */
	public ListaGenericaEnlazada<String> caminoMasCorto(String ciudad1, String ciudad2) {
		ListaGenericaEnlazada<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			this.caminoMinNoPesado(i, mapaCiudades, res, ciudad2);
		}
		return res;
	}
	private void dijkstra(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> lis, String ciudad2) {//Dijkstra(G,w, s){
		ListaGenerica<Arista<String>> ady = null;
		Integer[] D = new Integer[grafo.listaDeVertices().tamanio()];
		Integer[] P = new Integer[grafo.listaDeVertices().tamanio()];
		boolean[] C = new boolean[grafo.listaDeVertices().tamanio()];
		int j, k, l;
		boolean llegue = false;
			
		for (j = 0; j < grafo.listaDeVertices().tamanio(); j++) {//(1) para cada vértice v Є V
			D[j] = null;//(2) Dv = ∞; Pv = 0;
			P[j] = 0;
			C[j] = false;
		}
		D[i] = 0;//(3) Ds = 0;
		for (j=0; j<grafo.listaDeVertices().tamanio() && !llegue; j++) {//(4) para cada vértice v Є V {
			int min = Integer.MAX_VALUE, posMin = 0;
			for (k=0; k<grafo.listaDeVertices().tamanio(); k++) {//(5) u = vérticeDesconocidoMenorDist;
				if ((!C[k]) && (D[k]!=null)) {
					if (D[k]<min) {
						min = D[k];
						posMin = k;
					}
				}
			}
			C[posMin] = true;//(6) Marcar u como conocido;
			Vertice<String> v = grafo.listaDeVertices().elemento(posMin);
			ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			while (!ady.fin()) {//(7) para cada vértice w Є V adyacente a u
				Arista<String> arista = ady.proximo();
				l = arista.verticeDestino().posicion();
				if (!C[l]) {//(8) si (w no está conocido)
					Vertice<String> w = arista.verticeDestino();
					(D[l] > D[v.posicion()] + arista.peso());
					P[l] = v.posicion();
					if (arista.verticeDestino().dato().equals(ciudad2)) {
						llegue = true;
						k = j;
						break;
					}
				}
			}
			
		}
		
			
			
			
			
			//(9) si (Dw > Du + c(u,w)) {
			//(10) Dw = Du + c(u,w);
			//(11) Pw = u;
			//(12) }
			//(13) }
			//(14) }
	}// }
	
	private void caminoMinNoPesado(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> lis, String ciudad2) {
		ListaGenerica<Arista<String>> ady = null;
		Integer[] D = new Integer[mapaCiudades.listaDeVertices().tamanio()];
		Integer[] P = new Integer[mapaCiudades.listaDeVertices().tamanio()];
		int j, k = i;
		boolean llegue = false;
		for (j = 0; j < grafo.listaDeVertices().tamanio(); j++) {
			D[j] = null;
			P[j] = 0;
		}
		Cola<Vertice<String>> q = new Cola<Vertice<String>>();
		q.encolar(grafo.listaDeVertices().elemento(i));
		D[i] = 0;
		while (!q.esVacia() && !llegue) {
			Vertice<String> v = q.desencolar();
			ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			while (!ady.fin()) {
				Arista<String> arista = ady.proximo();
				j = arista.verticeDestino().posicion();
				if (D[j] == null) {
					Vertice<String> w = arista.verticeDestino();
					D[j] = D[v.posicion()] + 1;
					P[j] = v.posicion();
					if (arista.verticeDestino().dato().equals(ciudad2)) {
						llegue = true;
						k = j;
						break;
					}
					q.encolar(w);
				}
			}
		}
		if (llegue) {
			int pos = k;
			while (D[pos] != 0) {
				lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
				pos = P[pos];
			}
			lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
		}

	}

	
	/*
	 * El método caminoSinCargarCombustible(String ciudad1, String ciudad2, int
	 * tanqueAuto): ListaGenerica<String> // Retorna la lista de ciudades que forman
	 * un camino para llegar de ciudad1 a ciudad2. El auto no debe quedarse sin
	 * combustible y no puede cargar. Si no existe camino retorna la lista vacía.
	 */
	public ListaGenerica<String> caminoSinCargarCombustible(String ciudad1, String ciudad2, int tanqueAuto) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.caminoSinCargarCombustible(i, mapaCiudades, res, ciudad2, tanqueAuto, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}
	private boolean caminoSinCargarCombustible(int i, Grafo<String> grafo, ListaGenerica<String> lis, String ciudad2, int tanqueAuto, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.caminoSinCargarCombustible(j, grafo, lis, ciudad2, tanqueAuto, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}
	
	
	
	/*
	 * El método caminoConMenorCargaDeCombustible (String ciudad1, String ciudad2,
	 * int tanqueAuto): ListaGenerica<String> // Retorna la lista de ciudades que
	 * forman un camino para llegar de ciudad1 a ciudad2 teniendo en cuenta que el
	 * auto debe cargar la menor cantidad de veces. El auto no se debe quedar sin
	 * combustible en medio de una ruta, además puede completar su tanque al llegar
	 * a cualquier ciudad. Si no existe camino retorna la lista vacía.
	 */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-06-06 18:11:11.366
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-06-06 18:11:11.366
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-06 18:11:11.605
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package prog3.grafos.ejercicios;

import prog3.grafos.*;
import prog3.listagenerica.*;
import prog3.util.*;

public class Mapa {

	Grafo<String> mapaCiudades = new GrafoImplListAdy<String>();

	public Mapa(Grafo<String> mapaCiudades) {
		super();
		this.mapaCiudades = mapaCiudades;
	}

	/*
	 * El método devolverCamino (String ciudad1, String ciudad2):
	 * ListaGenerica<String> // Retorna la lista de ciudades que se deben atravesar
	 * para ir de ciudad1 a ciudad2 en caso que se pueda llegar, si no retorna la
	 * lista vacía. (Sin tener en cuenta el combustible).
	 */
	public ListaGenerica<String> devolverCamino(String ciudad1, String ciudad2) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.devolverCamino(i, mapaCiudades, res, ciudad2, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}
	private boolean devolverCamino(int i, Grafo<String> grafo, ListaGenerica<String> lis, String ciudad2,
			boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.devolverCamino(j, grafo, lis, ciudad2, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	
	/*
	 * El método devolverCaminoExceptuando (String ciudad1, String ciudad2,
	 * ListaGenerica<String> ciudades): ListaGenerica<String> // Retorna la lista de
	 * ciudades que forman un camino desde ciudad1 a ciudad2, sin pasar por las
	 * ciudades que están contenidas en la lista ciudades pasada por parámetro, si
	 * no existe camino retorna la lista vacía. (Sin tener en cuenta el
	 * combustible).
	 */
	public ListaGenerica<String> devolverCaminoExceptuando(String ciudad1, String ciudad2,
			ListaGenerica<String> ciudades) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.devolverCaminoExceptuando(i, mapaCiudades, res, ciudades, ciudad2, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}
	private boolean devolverCaminoExceptuando(int i, Grafo<String> grafo, ListaGenerica<String> lis,
			ListaGenerica<String> excepto, String ciudad2, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		excepto.comenzar();
		while (!excepto.fin()) {
			if (v.dato().equals(excepto.proximo())) {
				return false;
			}
		}
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.devolverCaminoExceptuando(j, grafo, lis, excepto, ciudad2, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				marca[i] = false;
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	
	/*
	 * El método caminoMasCorto(String ciudad1, String ciudad2):
	 * ListaGenerica<String> // Retorna la lista de ciudades que forman el camino
	 * más corto para llegar de ciudad1 a ciudad2, si no existe camino retorna la
	 * lista vacía. (Las rutas poseen la distancia). (Sin tener en cuenta el
	 * combustible).
	 */
	public ListaGenericaEnlazada<String> caminoMasCorto(String ciudad1, String ciudad2) {
		ListaGenericaEnlazada<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			this.caminoMinNoPesado(i, mapaCiudades, res, ciudad2);
		}
		return res;
	}
	private void dijkstra(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> lis, String ciudad2) {//Dijkstra(G,w, s){
		ListaGenerica<Arista<String>> ady = null;
		Integer[] D = new Integer[grafo.listaDeVertices().tamanio()];
		Integer[] P = new Integer[grafo.listaDeVertices().tamanio()];
		boolean[] C = new boolean[grafo.listaDeVertices().tamanio()];
		int j, k, l;
		boolean llegue = false;
			
		for (j = 0; j < grafo.listaDeVertices().tamanio(); j++) {//(1) para cada vértice v Є V
			D[j] = null;//(2) Dv = ∞; Pv = 0;
			P[j] = 0;
			C[j] = false;
		}
		D[i] = 0;//(3) Ds = 0;
		for (j=0; j<grafo.listaDeVertices().tamanio() && !llegue; j++) {//(4) para cada vértice v Є V {
			int min = Integer.MAX_VALUE, posMin = 0;
			for (k=0; k<grafo.listaDeVertices().tamanio(); k++) {//(5) u = vérticeDesconocidoMenorDist;
				if ((!C[k]) && (D[k]!=null)) {
					if (D[k]<min) {
						min = D[k];
						posMin = k;
					}
				}
			}
			C[posMin] = true;//(6) Marcar u como conocido;
			Vertice<String> v = grafo.listaDeVertices().elemento(posMin);
			ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			while (!ady.fin()) {//(7) para cada vértice w Є V adyacente a u
				Arista<String> arista = ady.proximo();
				l = arista.verticeDestino().posicion();
				if (!C[l]) {//(8) si (w no está conocido)
					Vertice<String> w = arista.verticeDestino();
					(D[l] > D[v.posicion()] + arista.peso());
					P[l] = v.posicion();
					if (arista.verticeDestino().dato().equals(ciudad2)) {
						llegue = true;
						k = j;
						break;
					}
				}
			}
			
		}
		
			
			
			
			
			//(9) si (Dw > Du + c(u,w)) {
			//(10) Dw = Du + c(u,w);
			//(11) Pw = u;
			//(12) }
			//(13) }
			//(14) }
	}// }
	
	private void caminoMinNoPesado(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> lis, String ciudad2) {
		ListaGenerica<Arista<String>> ady = null;
		Integer[] D = new Integer[mapaCiudades.listaDeVertices().tamanio()];
		Integer[] P = new Integer[mapaCiudades.listaDeVertices().tamanio()];
		int j, k = i;
		boolean llegue = false;
		for (j = 0; j < grafo.listaDeVertices().tamanio(); j++) {
			D[j] = null;
			P[j] = 0;
		}
		Cola<Vertice<String>> q = new Cola<Vertice<String>>();
		q.encolar(grafo.listaDeVertices().elemento(i));
		D[i] = 0;
		while (!q.esVacia() && !llegue) {
			Vertice<String> v = q.desencolar();
			ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			while (!ady.fin()) {
				Arista<String> arista = ady.proximo();
				j = arista.verticeDestino().posicion();
				if (D[j] == null) {
					Vertice<String> w = arista.verticeDestino();
					D[j] = D[v.posicion()] + 1;
					P[j] = v.posicion();
					if (arista.verticeDestino().dato().equals(ciudad2)) {
						llegue = true;
						k = j;
						break;
					}
					q.encolar(w);
				}
			}
		}
		if (llegue) {
			int pos = k;
			while (D[pos] != 0) {
				lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
				pos = P[pos];
			}
			lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
		}

	}

	
	/*
	 * El método caminoSinCargarCombustible(String ciudad1, String ciudad2, int
	 * tanqueAuto): ListaGenerica<String> // Retorna la lista de ciudades que forman
	 * un camino para llegar de ciudad1 a ciudad2. El auto no debe quedarse sin
	 * combustible y no puede cargar. Si no existe camino retorna la lista vacía.
	 */
	public ListaGenerica<String> caminoSinCargarCombustible(String ciudad1, String ciudad2, int tanqueAuto) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.caminoSinCargarCombustible(i, mapaCiudades, res, ciudad2, tanqueAuto, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}
	private boolean caminoSinCargarCombustible(int i, Grafo<String> grafo, ListaGenerica<String> lis, String ciudad2, int tanqueAuto, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.caminoSinCargarCombustible(j, grafo, lis, ciudad2, tanqueAuto, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}
	
	
	
	/*
	 * El método caminoConMenorCargaDeCombustible (String ciudad1, String ciudad2,
	 * int tanqueAuto): ListaGenerica<String> // Retorna la lista de ciudades que
	 * forman un camino para llegar de ciudad1 a ciudad2 teniendo en cuenta que el
	 * auto debe cargar la menor cantidad de veces. El auto no se debe quedar sin
	 * combustible en medio de una ruta, además puede completar su tanque al llegar
	 * a cualquier ciudad. Si no existe camino retorna la lista vacía.
	 */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-06 18:11:11.606
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-06 18:11:11.607
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-06 18:11:13.112
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package prog3.grafos.ejercicios;

import prog3.grafos.*;
import prog3.listagenerica.*;
import prog3.util.*;

public class Mapa {

	Grafo<String> mapaCiudades = new GrafoImplListAdy<String>();

	public Mapa(Grafo<String> mapaCiudades) {
		super();
		this.mapaCiudades = mapaCiudades;
	}

	/*
	 * El método devolverCamino (String ciudad1, String ciudad2):
	 * ListaGenerica<String> // Retorna la lista de ciudades que se deben atravesar
	 * para ir de ciudad1 a ciudad2 en caso que se pueda llegar, si no retorna la
	 * lista vacía. (Sin tener en cuenta el combustible).
	 */
	public ListaGenerica<String> devolverCamino(String ciudad1, String ciudad2) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.devolverCamino(i, mapaCiudades, res, ciudad2, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}
	private boolean devolverCamino(int i, Grafo<String> grafo, ListaGenerica<String> lis, String ciudad2,
			boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.devolverCamino(j, grafo, lis, ciudad2, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	
	/*
	 * El método devolverCaminoExceptuando (String ciudad1, String ciudad2,
	 * ListaGenerica<String> ciudades): ListaGenerica<String> // Retorna la lista de
	 * ciudades que forman un camino desde ciudad1 a ciudad2, sin pasar por las
	 * ciudades que están contenidas en la lista ciudades pasada por parámetro, si
	 * no existe camino retorna la lista vacía. (Sin tener en cuenta el
	 * combustible).
	 */
	public ListaGenerica<String> devolverCaminoExceptuando(String ciudad1, String ciudad2,
			ListaGenerica<String> ciudades) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.devolverCaminoExceptuando(i, mapaCiudades, res, ciudades, ciudad2, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}
	private boolean devolverCaminoExceptuando(int i, Grafo<String> grafo, ListaGenerica<String> lis,
			ListaGenerica<String> excepto, String ciudad2, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		excepto.comenzar();
		while (!excepto.fin()) {
			if (v.dato().equals(excepto.proximo())) {
				return false;
			}
		}
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.devolverCaminoExceptuando(j, grafo, lis, excepto, ciudad2, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				marca[i] = false;
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	
	/*
	 * El método caminoMasCorto(String ciudad1, String ciudad2):
	 * ListaGenerica<String> // Retorna la lista de ciudades que forman el camino
	 * más corto para llegar de ciudad1 a ciudad2, si no existe camino retorna la
	 * lista vacía. (Las rutas poseen la distancia). (Sin tener en cuenta el
	 * combustible).
	 */
	public ListaGenericaEnlazada<String> caminoMasCorto(String ciudad1, String ciudad2) {
		ListaGenericaEnlazada<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			this.caminoMinNoPesado(i, mapaCiudades, res, ciudad2);
		}
		return res;
	}
	private void dijkstra(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> lis, String ciudad2) {//Dijkstra(G,w, s){
		ListaGenerica<Arista<String>> ady = null;
		Integer[] D = new Integer[grafo.listaDeVertices().tamanio()];
		Integer[] P = new Integer[grafo.listaDeVertices().tamanio()];
		boolean[] C = new boolean[grafo.listaDeVertices().tamanio()];
		int j, k, l;
		boolean llegue = false;
			
		for (j = 0; j < grafo.listaDeVertices().tamanio(); j++) {//(1) para cada vértice v Є V
			D[j] = null;//(2) Dv = ∞; Pv = 0;
			P[j] = 0;
			C[j] = false;
		}
		D[i] = 0;//(3) Ds = 0;
		for (j=0; j<grafo.listaDeVertices().tamanio() && !llegue; j++) {//(4) para cada vértice v Є V {
			int min = Integer.MAX_VALUE, posMin = 0;
			for (k=0; k<grafo.listaDeVertices().tamanio(); k++) {//(5) u = vérticeDesconocidoMenorDist;
				if ((!C[k]) && (D[k]!=null)) {
					if (D[k]<min) {
						min = D[k];
						posMin = k;
					}
				}
			}
			C[posMin] = true;//(6) Marcar u como conocido;
			Vertice<String> v = grafo.listaDeVertices().elemento(posMin);
			ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			while (!ady.fin()) {//(7) para cada vértice w Є V adyacente a u
				Arista<String> arista = ady.proximo();
				l = arista.verticeDestino().posicion();
				if (!C[l]) {//(8) si (w no está conocido)
					Vertice<String> w = arista.verticeDestino();
					(D[l] > (D[v.posicion()] + arista.peso());
					P[l] = v.posicion();
					if (arista.verticeDestino().dato().equals(ciudad2)) {
						llegue = true;
						k = j;
						break;
					}
				}
			}
			
		}
		
			
			
			
			
			//(9) si (Dw > Du + c(u,w)) {
			//(10) Dw = Du + c(u,w);
			//(11) Pw = u;
			//(12) }
			//(13) }
			//(14) }
	}// }
	
	private void caminoMinNoPesado(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> lis, String ciudad2) {
		ListaGenerica<Arista<String>> ady = null;
		Integer[] D = new Integer[mapaCiudades.listaDeVertices().tamanio()];
		Integer[] P = new Integer[mapaCiudades.listaDeVertices().tamanio()];
		int j, k = i;
		boolean llegue = false;
		for (j = 0; j < grafo.listaDeVertices().tamanio(); j++) {
			D[j] = null;
			P[j] = 0;
		}
		Cola<Vertice<String>> q = new Cola<Vertice<String>>();
		q.encolar(grafo.listaDeVertices().elemento(i));
		D[i] = 0;
		while (!q.esVacia() && !llegue) {
			Vertice<String> v = q.desencolar();
			ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			while (!ady.fin()) {
				Arista<String> arista = ady.proximo();
				j = arista.verticeDestino().posicion();
				if (D[j] == null) {
					Vertice<String> w = arista.verticeDestino();
					D[j] = D[v.posicion()] + 1;
					P[j] = v.posicion();
					if (arista.verticeDestino().dato().equals(ciudad2)) {
						llegue = true;
						k = j;
						break;
					}
					q.encolar(w);
				}
			}
		}
		if (llegue) {
			int pos = k;
			while (D[pos] != 0) {
				lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
				pos = P[pos];
			}
			lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
		}

	}

	
	/*
	 * El método caminoSinCargarCombustible(String ciudad1, String ciudad2, int
	 * tanqueAuto): ListaGenerica<String> // Retorna la lista de ciudades que forman
	 * un camino para llegar de ciudad1 a ciudad2. El auto no debe quedarse sin
	 * combustible y no puede cargar. Si no existe camino retorna la lista vacía.
	 */
	public ListaGenerica<String> caminoSinCargarCombustible(String ciudad1, String ciudad2, int tanqueAuto) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.caminoSinCargarCombustible(i, mapaCiudades, res, ciudad2, tanqueAuto, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}
	private boolean caminoSinCargarCombustible(int i, Grafo<String> grafo, ListaGenerica<String> lis, String ciudad2, int tanqueAuto, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.caminoSinCargarCombustible(j, grafo, lis, ciudad2, tanqueAuto, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}
	
	
	
	/*
	 * El método caminoConMenorCargaDeCombustible (String ciudad1, String ciudad2,
	 * int tanqueAuto): ListaGenerica<String> // Retorna la lista de ciudades que
	 * forman un camino para llegar de ciudad1 a ciudad2 teniendo en cuenta que el
	 * auto debe cargar la menor cantidad de veces. El auto no se debe quedar sin
	 * combustible en medio de una ruta, además puede completar su tanque al llegar
	 * a cualquier ciudad. Si no existe camino retorna la lista vacía.
	 */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-06-06 18:11:13.113
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-06-06 18:11:13.114
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-06 18:11:13.125
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package prog3.grafos.ejercicios;

import prog3.grafos.*;
import prog3.listagenerica.*;
import prog3.util.*;

public class Mapa {

	Grafo<String> mapaCiudades = new GrafoImplListAdy<String>();

	public Mapa(Grafo<String> mapaCiudades) {
		super();
		this.mapaCiudades = mapaCiudades;
	}

	/*
	 * El método devolverCamino (String ciudad1, String ciudad2):
	 * ListaGenerica<String> // Retorna la lista de ciudades que se deben atravesar
	 * para ir de ciudad1 a ciudad2 en caso que se pueda llegar, si no retorna la
	 * lista vacía. (Sin tener en cuenta el combustible).
	 */
	public ListaGenerica<String> devolverCamino(String ciudad1, String ciudad2) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.devolverCamino(i, mapaCiudades, res, ciudad2, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}
	private boolean devolverCamino(int i, Grafo<String> grafo, ListaGenerica<String> lis, String ciudad2,
			boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.devolverCamino(j, grafo, lis, ciudad2, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	
	/*
	 * El método devolverCaminoExceptuando (String ciudad1, String ciudad2,
	 * ListaGenerica<String> ciudades): ListaGenerica<String> // Retorna la lista de
	 * ciudades que forman un camino desde ciudad1 a ciudad2, sin pasar por las
	 * ciudades que están contenidas en la lista ciudades pasada por parámetro, si
	 * no existe camino retorna la lista vacía. (Sin tener en cuenta el
	 * combustible).
	 */
	public ListaGenerica<String> devolverCaminoExceptuando(String ciudad1, String ciudad2,
			ListaGenerica<String> ciudades) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.devolverCaminoExceptuando(i, mapaCiudades, res, ciudades, ciudad2, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}
	private boolean devolverCaminoExceptuando(int i, Grafo<String> grafo, ListaGenerica<String> lis,
			ListaGenerica<String> excepto, String ciudad2, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		excepto.comenzar();
		while (!excepto.fin()) {
			if (v.dato().equals(excepto.proximo())) {
				return false;
			}
		}
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.devolverCaminoExceptuando(j, grafo, lis, excepto, ciudad2, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				marca[i] = false;
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	
	/*
	 * El método caminoMasCorto(String ciudad1, String ciudad2):
	 * ListaGenerica<String> // Retorna la lista de ciudades que forman el camino
	 * más corto para llegar de ciudad1 a ciudad2, si no existe camino retorna la
	 * lista vacía. (Las rutas poseen la distancia). (Sin tener en cuenta el
	 * combustible).
	 */
	public ListaGenericaEnlazada<String> caminoMasCorto(String ciudad1, String ciudad2) {
		ListaGenericaEnlazada<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			this.caminoMinNoPesado(i, mapaCiudades, res, ciudad2);
		}
		return res;
	}
	private void dijkstra(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> lis, String ciudad2) {//Dijkstra(G,w, s){
		ListaGenerica<Arista<String>> ady = null;
		Integer[] D = new Integer[grafo.listaDeVertices().tamanio()];
		Integer[] P = new Integer[grafo.listaDeVertices().tamanio()];
		boolean[] C = new boolean[grafo.listaDeVertices().tamanio()];
		int j, k, l;
		boolean llegue = false;
			
		for (j = 0; j < grafo.listaDeVertices().tamanio(); j++) {//(1) para cada vértice v Є V
			D[j] = null;//(2) Dv = ∞; Pv = 0;
			P[j] = 0;
			C[j] = false;
		}
		D[i] = 0;//(3) Ds = 0;
		for (j=0; j<grafo.listaDeVertices().tamanio() && !llegue; j++) {//(4) para cada vértice v Є V {
			int min = Integer.MAX_VALUE, posMin = 0;
			for (k=0; k<grafo.listaDeVertices().tamanio(); k++) {//(5) u = vérticeDesconocidoMenorDist;
				if ((!C[k]) && (D[k]!=null)) {
					if (D[k]<min) {
						min = D[k];
						posMin = k;
					}
				}
			}
			C[posMin] = true;//(6) Marcar u como conocido;
			Vertice<String> v = grafo.listaDeVertices().elemento(posMin);
			ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			while (!ady.fin()) {//(7) para cada vértice w Є V adyacente a u
				Arista<String> arista = ady.proximo();
				l = arista.verticeDestino().posicion();
				if (!C[l]) {//(8) si (w no está conocido)
					Vertice<String> w = arista.verticeDestino();
					(D[l] > (D[v.posicion()] + arista.peso());
					P[l] = v.posicion();
					if (arista.verticeDestino().dato().equals(ciudad2)) {
						llegue = true;
						k = j;
						break;
					}
				}
			}
			
		}
		
			
			
			
			
			//(9) si (Dw > Du + c(u,w)) {
			//(10) Dw = Du + c(u,w);
			//(11) Pw = u;
			//(12) }
			//(13) }
			//(14) }
	}// }
	
	private void caminoMinNoPesado(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> lis, String ciudad2) {
		ListaGenerica<Arista<String>> ady = null;
		Integer[] D = new Integer[mapaCiudades.listaDeVertices().tamanio()];
		Integer[] P = new Integer[mapaCiudades.listaDeVertices().tamanio()];
		int j, k = i;
		boolean llegue = false;
		for (j = 0; j < grafo.listaDeVertices().tamanio(); j++) {
			D[j] = null;
			P[j] = 0;
		}
		Cola<Vertice<String>> q = new Cola<Vertice<String>>();
		q.encolar(grafo.listaDeVertices().elemento(i));
		D[i] = 0;
		while (!q.esVacia() && !llegue) {
			Vertice<String> v = q.desencolar();
			ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			while (!ady.fin()) {
				Arista<String> arista = ady.proximo();
				j = arista.verticeDestino().posicion();
				if (D[j] == null) {
					Vertice<String> w = arista.verticeDestino();
					D[j] = D[v.posicion()] + 1;
					P[j] = v.posicion();
					if (arista.verticeDestino().dato().equals(ciudad2)) {
						llegue = true;
						k = j;
						break;
					}
					q.encolar(w);
				}
			}
		}
		if (llegue) {
			int pos = k;
			while (D[pos] != 0) {
				lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
				pos = P[pos];
			}
			lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
		}

	}

	
	/*
	 * El método caminoSinCargarCombustible(String ciudad1, String ciudad2, int
	 * tanqueAuto): ListaGenerica<String> // Retorna la lista de ciudades que forman
	 * un camino para llegar de ciudad1 a ciudad2. El auto no debe quedarse sin
	 * combustible y no puede cargar. Si no existe camino retorna la lista vacía.
	 */
	public ListaGenerica<String> caminoSinCargarCombustible(String ciudad1, String ciudad2, int tanqueAuto) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.caminoSinCargarCombustible(i, mapaCiudades, res, ciudad2, tanqueAuto, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}
	private boolean caminoSinCargarCombustible(int i, Grafo<String> grafo, ListaGenerica<String> lis, String ciudad2, int tanqueAuto, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.caminoSinCargarCombustible(j, grafo, lis, ciudad2, tanqueAuto, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}
	
	
	
	/*
	 * El método caminoConMenorCargaDeCombustible (String ciudad1, String ciudad2,
	 * int tanqueAuto): ListaGenerica<String> // Retorna la lista de ciudades que
	 * forman un camino para llegar de ciudad1 a ciudad2 teniendo en cuenta que el
	 * auto debe cargar la menor cantidad de veces. El auto no se debe quedar sin
	 * combustible en medio de una ruta, además puede completar su tanque al llegar
	 * a cualquier ciudad. Si no existe camino retorna la lista vacía.
	 */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-06 18:11:13.126
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-06 18:11:13.127
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-06 18:11:13.631
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package prog3.grafos.ejercicios;

import prog3.grafos.*;
import prog3.listagenerica.*;
import prog3.util.*;

public class Mapa {

	Grafo<String> mapaCiudades = new GrafoImplListAdy<String>();

	public Mapa(Grafo<String> mapaCiudades) {
		super();
		this.mapaCiudades = mapaCiudades;
	}

	/*
	 * El método devolverCamino (String ciudad1, String ciudad2):
	 * ListaGenerica<String> // Retorna la lista de ciudades que se deben atravesar
	 * para ir de ciudad1 a ciudad2 en caso que se pueda llegar, si no retorna la
	 * lista vacía. (Sin tener en cuenta el combustible).
	 */
	public ListaGenerica<String> devolverCamino(String ciudad1, String ciudad2) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.devolverCamino(i, mapaCiudades, res, ciudad2, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}
	private boolean devolverCamino(int i, Grafo<String> grafo, ListaGenerica<String> lis, String ciudad2,
			boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.devolverCamino(j, grafo, lis, ciudad2, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	
	/*
	 * El método devolverCaminoExceptuando (String ciudad1, String ciudad2,
	 * ListaGenerica<String> ciudades): ListaGenerica<String> // Retorna la lista de
	 * ciudades que forman un camino desde ciudad1 a ciudad2, sin pasar por las
	 * ciudades que están contenidas en la lista ciudades pasada por parámetro, si
	 * no existe camino retorna la lista vacía. (Sin tener en cuenta el
	 * combustible).
	 */
	public ListaGenerica<String> devolverCaminoExceptuando(String ciudad1, String ciudad2,
			ListaGenerica<String> ciudades) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.devolverCaminoExceptuando(i, mapaCiudades, res, ciudades, ciudad2, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}
	private boolean devolverCaminoExceptuando(int i, Grafo<String> grafo, ListaGenerica<String> lis,
			ListaGenerica<String> excepto, String ciudad2, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		excepto.comenzar();
		while (!excepto.fin()) {
			if (v.dato().equals(excepto.proximo())) {
				return false;
			}
		}
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.devolverCaminoExceptuando(j, grafo, lis, excepto, ciudad2, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				marca[i] = false;
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	
	/*
	 * El método caminoMasCorto(String ciudad1, String ciudad2):
	 * ListaGenerica<String> // Retorna la lista de ciudades que forman el camino
	 * más corto para llegar de ciudad1 a ciudad2, si no existe camino retorna la
	 * lista vacía. (Las rutas poseen la distancia). (Sin tener en cuenta el
	 * combustible).
	 */
	public ListaGenericaEnlazada<String> caminoMasCorto(String ciudad1, String ciudad2) {
		ListaGenericaEnlazada<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			this.caminoMinNoPesado(i, mapaCiudades, res, ciudad2);
		}
		return res;
	}
	private void dijkstra(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> lis, String ciudad2) {//Dijkstra(G,w, s){
		ListaGenerica<Arista<String>> ady = null;
		Integer[] D = new Integer[grafo.listaDeVertices().tamanio()];
		Integer[] P = new Integer[grafo.listaDeVertices().tamanio()];
		boolean[] C = new boolean[grafo.listaDeVertices().tamanio()];
		int j, k, l;
		boolean llegue = false;
			
		for (j = 0; j < grafo.listaDeVertices().tamanio(); j++) {//(1) para cada vértice v Є V
			D[j] = null;//(2) Dv = ∞; Pv = 0;
			P[j] = 0;
			C[j] = false;
		}
		D[i] = 0;//(3) Ds = 0;
		for (j=0; j<grafo.listaDeVertices().tamanio() && !llegue; j++) {//(4) para cada vértice v Є V {
			int min = Integer.MAX_VALUE, posMin = 0;
			for (k=0; k<grafo.listaDeVertices().tamanio(); k++) {//(5) u = vérticeDesconocidoMenorDist;
				if ((!C[k]) && (D[k]!=null)) {
					if (D[k]<min) {
						min = D[k];
						posMin = k;
					}
				}
			}
			C[posMin] = true;//(6) Marcar u como conocido;
			Vertice<String> v = grafo.listaDeVertices().elemento(posMin);
			ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			while (!ady.fin()) {//(7) para cada vértice w Є V adyacente a u
				Arista<String> arista = ady.proximo();
				l = arista.verticeDestino().posicion();
				if (!C[l]) {//(8) si (w no está conocido)
					Vertice<String> w = arista.verticeDestino();
					(D[l] > (D[v.posicion()] + arista.peso());
					P[l] = v.posicion();
					if (arista.verticeDestino().dato().equals(ciudad2)) {
						llegue = true;
						k = j;
						break;
					}
				}
			}
			
		}
		
			
			
			
			
			//(9) si (Dw > Du + c(u,w)) {
			//(10) Dw = Du + c(u,w);
			//(11) Pw = u;
			//(12) }
			//(13) }
			//(14) }
	}// }
	
	private void caminoMinNoPesado(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> lis, String ciudad2) {
		ListaGenerica<Arista<String>> ady = null;
		Integer[] D = new Integer[mapaCiudades.listaDeVertices().tamanio()];
		Integer[] P = new Integer[mapaCiudades.listaDeVertices().tamanio()];
		int j, k = i;
		boolean llegue = false;
		for (j = 0; j < grafo.listaDeVertices().tamanio(); j++) {
			D[j] = null;
			P[j] = 0;
		}
		Cola<Vertice<String>> q = new Cola<Vertice<String>>();
		q.encolar(grafo.listaDeVertices().elemento(i));
		D[i] = 0;
		while (!q.esVacia() && !llegue) {
			Vertice<String> v = q.desencolar();
			ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			while (!ady.fin()) {
				Arista<String> arista = ady.proximo();
				j = arista.verticeDestino().posicion();
				if (D[j] == null) {
					Vertice<String> w = arista.verticeDestino();
					D[j] = D[v.posicion()] + 1;
					P[j] = v.posicion();
					if (arista.verticeDestino().dato().equals(ciudad2)) {
						llegue = true;
						k = j;
						break;
					}
					q.encolar(w);
				}
			}
		}
		if (llegue) {
			int pos = k;
			while (D[pos] != 0) {
				lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
				pos = P[pos];
			}
			lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
		}

	}

	
	/*
	 * El método caminoSinCargarCombustible(String ciudad1, String ciudad2, int
	 * tanqueAuto): ListaGenerica<String> // Retorna la lista de ciudades que forman
	 * un camino para llegar de ciudad1 a ciudad2. El auto no debe quedarse sin
	 * combustible y no puede cargar. Si no existe camino retorna la lista vacía.
	 */
	public ListaGenerica<String> caminoSinCargarCombustible(String ciudad1, String ciudad2, int tanqueAuto) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.caminoSinCargarCombustible(i, mapaCiudades, res, ciudad2, tanqueAuto, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}
	private boolean caminoSinCargarCombustible(int i, Grafo<String> grafo, ListaGenerica<String> lis, String ciudad2, int tanqueAuto, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.caminoSinCargarCombustible(j, grafo, lis, ciudad2, tanqueAuto, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}
	
	
	
	/*
	 * El método caminoConMenorCargaDeCombustible (String ciudad1, String ciudad2,
	 * int tanqueAuto): ListaGenerica<String> // Retorna la lista de ciudades que
	 * forman un camino para llegar de ciudad1 a ciudad2 teniendo en cuenta que el
	 * auto debe cargar la menor cantidad de veces. El auto no se debe quedar sin
	 * combustible en medio de una ruta, además puede completar su tanque al llegar
	 * a cualquier ciudad. Si no existe camino retorna la lista vacía.
	 */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-06 18:11:13.633
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-06 18:11:13.633
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-06 18:11:15.692
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package prog3.grafos.ejercicios;

import prog3.grafos.*;
import prog3.listagenerica.*;
import prog3.util.*;

public class Mapa {

	Grafo<String> mapaCiudades = new GrafoImplListAdy<String>();

	public Mapa(Grafo<String> mapaCiudades) {
		super();
		this.mapaCiudades = mapaCiudades;
	}

	/*
	 * El método devolverCamino (String ciudad1, String ciudad2):
	 * ListaGenerica<String> // Retorna la lista de ciudades que se deben atravesar
	 * para ir de ciudad1 a ciudad2 en caso que se pueda llegar, si no retorna la
	 * lista vacía. (Sin tener en cuenta el combustible).
	 */
	public ListaGenerica<String> devolverCamino(String ciudad1, String ciudad2) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.devolverCamino(i, mapaCiudades, res, ciudad2, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}
	private boolean devolverCamino(int i, Grafo<String> grafo, ListaGenerica<String> lis, String ciudad2,
			boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.devolverCamino(j, grafo, lis, ciudad2, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	
	/*
	 * El método devolverCaminoExceptuando (String ciudad1, String ciudad2,
	 * ListaGenerica<String> ciudades): ListaGenerica<String> // Retorna la lista de
	 * ciudades que forman un camino desde ciudad1 a ciudad2, sin pasar por las
	 * ciudades que están contenidas en la lista ciudades pasada por parámetro, si
	 * no existe camino retorna la lista vacía. (Sin tener en cuenta el
	 * combustible).
	 */
	public ListaGenerica<String> devolverCaminoExceptuando(String ciudad1, String ciudad2,
			ListaGenerica<String> ciudades) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.devolverCaminoExceptuando(i, mapaCiudades, res, ciudades, ciudad2, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}
	private boolean devolverCaminoExceptuando(int i, Grafo<String> grafo, ListaGenerica<String> lis,
			ListaGenerica<String> excepto, String ciudad2, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		excepto.comenzar();
		while (!excepto.fin()) {
			if (v.dato().equals(excepto.proximo())) {
				return false;
			}
		}
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.devolverCaminoExceptuando(j, grafo, lis, excepto, ciudad2, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				marca[i] = false;
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	
	/*
	 * El método caminoMasCorto(String ciudad1, String ciudad2):
	 * ListaGenerica<String> // Retorna la lista de ciudades que forman el camino
	 * más corto para llegar de ciudad1 a ciudad2, si no existe camino retorna la
	 * lista vacía. (Las rutas poseen la distancia). (Sin tener en cuenta el
	 * combustible).
	 */
	public ListaGenericaEnlazada<String> caminoMasCorto(String ciudad1, String ciudad2) {
		ListaGenericaEnlazada<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			this.caminoMinNoPesado(i, mapaCiudades, res, ciudad2);
		}
		return res;
	}
	private void dijkstra(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> lis, String ciudad2) {//Dijkstra(G,w, s){
		ListaGenerica<Arista<String>> ady = null;
		Integer[] D = new Integer[grafo.listaDeVertices().tamanio()];
		Integer[] P = new Integer[grafo.listaDeVertices().tamanio()];
		boolean[] C = new boolean[grafo.listaDeVertices().tamanio()];
		int j, k, l;
		boolean llegue = false;
			
		for (j = 0; j < grafo.listaDeVertices().tamanio(); j++) {//(1) para cada vértice v Є V
			D[j] = null;//(2) Dv = ∞; Pv = 0;
			P[j] = 0;
			C[j] = false;
		}
		D[i] = 0;//(3) Ds = 0;
		for (j=0; j<grafo.listaDeVertices().tamanio() && !llegue; j++) {//(4) para cada vértice v Є V {
			int min = Integer.MAX_VALUE, posMin = 0;
			for (k=0; k<grafo.listaDeVertices().tamanio(); k++) {//(5) u = vérticeDesconocidoMenorDist;
				if ((!C[k]) && (D[k]!=null)) {
					if (D[k]<min) {
						min = D[k];
						posMin = k;
					}
				}
			}
			C[posMin] = true;//(6) Marcar u como conocido;
			Vertice<String> v = grafo.listaDeVertices().elemento(posMin);
			ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			while (!ady.fin()) {//(7) para cada vértice w Є V adyacente a u
				Arista<String> arista = ady.proximo();
				l = arista.verticeDestino().posicion();
				if (!C[l]) {//(8) si (w no está conocido)
					Vertice<String> w = arista.verticeDestino();
					(D[l] > (D[v.posicion()] + arista.peso()));
					P[l] = v.posicion();
					if (arista.verticeDestino().dato().equals(ciudad2)) {
						llegue = true;
						k = j;
						break;
					}
				}
			}
			
		}
		
			
			
			
			
			//(9) si (Dw > Du + c(u,w)) {
			//(10) Dw = Du + c(u,w);
			//(11) Pw = u;
			//(12) }
			//(13) }
			//(14) }
	}// }
	
	private void caminoMinNoPesado(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> lis, String ciudad2) {
		ListaGenerica<Arista<String>> ady = null;
		Integer[] D = new Integer[mapaCiudades.listaDeVertices().tamanio()];
		Integer[] P = new Integer[mapaCiudades.listaDeVertices().tamanio()];
		int j, k = i;
		boolean llegue = false;
		for (j = 0; j < grafo.listaDeVertices().tamanio(); j++) {
			D[j] = null;
			P[j] = 0;
		}
		Cola<Vertice<String>> q = new Cola<Vertice<String>>();
		q.encolar(grafo.listaDeVertices().elemento(i));
		D[i] = 0;
		while (!q.esVacia() && !llegue) {
			Vertice<String> v = q.desencolar();
			ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			while (!ady.fin()) {
				Arista<String> arista = ady.proximo();
				j = arista.verticeDestino().posicion();
				if (D[j] == null) {
					Vertice<String> w = arista.verticeDestino();
					D[j] = D[v.posicion()] + 1;
					P[j] = v.posicion();
					if (arista.verticeDestino().dato().equals(ciudad2)) {
						llegue = true;
						k = j;
						break;
					}
					q.encolar(w);
				}
			}
		}
		if (llegue) {
			int pos = k;
			while (D[pos] != 0) {
				lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
				pos = P[pos];
			}
			lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
		}

	}

	
	/*
	 * El método caminoSinCargarCombustible(String ciudad1, String ciudad2, int
	 * tanqueAuto): ListaGenerica<String> // Retorna la lista de ciudades que forman
	 * un camino para llegar de ciudad1 a ciudad2. El auto no debe quedarse sin
	 * combustible y no puede cargar. Si no existe camino retorna la lista vacía.
	 */
	public ListaGenerica<String> caminoSinCargarCombustible(String ciudad1, String ciudad2, int tanqueAuto) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.caminoSinCargarCombustible(i, mapaCiudades, res, ciudad2, tanqueAuto, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}
	private boolean caminoSinCargarCombustible(int i, Grafo<String> grafo, ListaGenerica<String> lis, String ciudad2, int tanqueAuto, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.caminoSinCargarCombustible(j, grafo, lis, ciudad2, tanqueAuto, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}
	
	
	
	/*
	 * El método caminoConMenorCargaDeCombustible (String ciudad1, String ciudad2,
	 * int tanqueAuto): ListaGenerica<String> // Retorna la lista de ciudades que
	 * forman un camino para llegar de ciudad1 a ciudad2 teniendo en cuenta que el
	 * auto debe cargar la menor cantidad de veces. El auto no se debe quedar sin
	 * combustible en medio de una ruta, además puede completar su tanque al llegar
	 * a cualquier ciudad. Si no existe camino retorna la lista vacía.
	 */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-06-06 18:11:15.692
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-06-06 18:11:15.692
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-06 18:11:15.703
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package prog3.grafos.ejercicios;

import prog3.grafos.*;
import prog3.listagenerica.*;
import prog3.util.*;

public class Mapa {

	Grafo<String> mapaCiudades = new GrafoImplListAdy<String>();

	public Mapa(Grafo<String> mapaCiudades) {
		super();
		this.mapaCiudades = mapaCiudades;
	}

	/*
	 * El método devolverCamino (String ciudad1, String ciudad2):
	 * ListaGenerica<String> // Retorna la lista de ciudades que se deben atravesar
	 * para ir de ciudad1 a ciudad2 en caso que se pueda llegar, si no retorna la
	 * lista vacía. (Sin tener en cuenta el combustible).
	 */
	public ListaGenerica<String> devolverCamino(String ciudad1, String ciudad2) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.devolverCamino(i, mapaCiudades, res, ciudad2, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}
	private boolean devolverCamino(int i, Grafo<String> grafo, ListaGenerica<String> lis, String ciudad2,
			boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.devolverCamino(j, grafo, lis, ciudad2, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	
	/*
	 * El método devolverCaminoExceptuando (String ciudad1, String ciudad2,
	 * ListaGenerica<String> ciudades): ListaGenerica<String> // Retorna la lista de
	 * ciudades que forman un camino desde ciudad1 a ciudad2, sin pasar por las
	 * ciudades que están contenidas en la lista ciudades pasada por parámetro, si
	 * no existe camino retorna la lista vacía. (Sin tener en cuenta el
	 * combustible).
	 */
	public ListaGenerica<String> devolverCaminoExceptuando(String ciudad1, String ciudad2,
			ListaGenerica<String> ciudades) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.devolverCaminoExceptuando(i, mapaCiudades, res, ciudades, ciudad2, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}
	private boolean devolverCaminoExceptuando(int i, Grafo<String> grafo, ListaGenerica<String> lis,
			ListaGenerica<String> excepto, String ciudad2, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		excepto.comenzar();
		while (!excepto.fin()) {
			if (v.dato().equals(excepto.proximo())) {
				return false;
			}
		}
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.devolverCaminoExceptuando(j, grafo, lis, excepto, ciudad2, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				marca[i] = false;
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	
	/*
	 * El método caminoMasCorto(String ciudad1, String ciudad2):
	 * ListaGenerica<String> // Retorna la lista de ciudades que forman el camino
	 * más corto para llegar de ciudad1 a ciudad2, si no existe camino retorna la
	 * lista vacía. (Las rutas poseen la distancia). (Sin tener en cuenta el
	 * combustible).
	 */
	public ListaGenericaEnlazada<String> caminoMasCorto(String ciudad1, String ciudad2) {
		ListaGenericaEnlazada<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			this.caminoMinNoPesado(i, mapaCiudades, res, ciudad2);
		}
		return res;
	}
	private void dijkstra(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> lis, String ciudad2) {//Dijkstra(G,w, s){
		ListaGenerica<Arista<String>> ady = null;
		Integer[] D = new Integer[grafo.listaDeVertices().tamanio()];
		Integer[] P = new Integer[grafo.listaDeVertices().tamanio()];
		boolean[] C = new boolean[grafo.listaDeVertices().tamanio()];
		int j, k, l;
		boolean llegue = false;
			
		for (j = 0; j < grafo.listaDeVertices().tamanio(); j++) {//(1) para cada vértice v Є V
			D[j] = null;//(2) Dv = ∞; Pv = 0;
			P[j] = 0;
			C[j] = false;
		}
		D[i] = 0;//(3) Ds = 0;
		for (j=0; j<grafo.listaDeVertices().tamanio() && !llegue; j++) {//(4) para cada vértice v Є V {
			int min = Integer.MAX_VALUE, posMin = 0;
			for (k=0; k<grafo.listaDeVertices().tamanio(); k++) {//(5) u = vérticeDesconocidoMenorDist;
				if ((!C[k]) && (D[k]!=null)) {
					if (D[k]<min) {
						min = D[k];
						posMin = k;
					}
				}
			}
			C[posMin] = true;//(6) Marcar u como conocido;
			Vertice<String> v = grafo.listaDeVertices().elemento(posMin);
			ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			while (!ady.fin()) {//(7) para cada vértice w Є V adyacente a u
				Arista<String> arista = ady.proximo();
				l = arista.verticeDestino().posicion();
				if (!C[l]) {//(8) si (w no está conocido)
					Vertice<String> w = arista.verticeDestino();
					(D[l] > (D[v.posicion()] + arista.peso()));
					P[l] = v.posicion();
					if (arista.verticeDestino().dato().equals(ciudad2)) {
						llegue = true;
						k = j;
						break;
					}
				}
			}
			
		}
		
			
			
			
			
			//(9) si (Dw > Du + c(u,w)) {
			//(10) Dw = Du + c(u,w);
			//(11) Pw = u;
			//(12) }
			//(13) }
			//(14) }
	}// }
	
	private void caminoMinNoPesado(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> lis, String ciudad2) {
		ListaGenerica<Arista<String>> ady = null;
		Integer[] D = new Integer[mapaCiudades.listaDeVertices().tamanio()];
		Integer[] P = new Integer[mapaCiudades.listaDeVertices().tamanio()];
		int j, k = i;
		boolean llegue = false;
		for (j = 0; j < grafo.listaDeVertices().tamanio(); j++) {
			D[j] = null;
			P[j] = 0;
		}
		Cola<Vertice<String>> q = new Cola<Vertice<String>>();
		q.encolar(grafo.listaDeVertices().elemento(i));
		D[i] = 0;
		while (!q.esVacia() && !llegue) {
			Vertice<String> v = q.desencolar();
			ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			while (!ady.fin()) {
				Arista<String> arista = ady.proximo();
				j = arista.verticeDestino().posicion();
				if (D[j] == null) {
					Vertice<String> w = arista.verticeDestino();
					D[j] = D[v.posicion()] + 1;
					P[j] = v.posicion();
					if (arista.verticeDestino().dato().equals(ciudad2)) {
						llegue = true;
						k = j;
						break;
					}
					q.encolar(w);
				}
			}
		}
		if (llegue) {
			int pos = k;
			while (D[pos] != 0) {
				lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
				pos = P[pos];
			}
			lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
		}

	}

	
	/*
	 * El método caminoSinCargarCombustible(String ciudad1, String ciudad2, int
	 * tanqueAuto): ListaGenerica<String> // Retorna la lista de ciudades que forman
	 * un camino para llegar de ciudad1 a ciudad2. El auto no debe quedarse sin
	 * combustible y no puede cargar. Si no existe camino retorna la lista vacía.
	 */
	public ListaGenerica<String> caminoSinCargarCombustible(String ciudad1, String ciudad2, int tanqueAuto) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.caminoSinCargarCombustible(i, mapaCiudades, res, ciudad2, tanqueAuto, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}
	private boolean caminoSinCargarCombustible(int i, Grafo<String> grafo, ListaGenerica<String> lis, String ciudad2, int tanqueAuto, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.caminoSinCargarCombustible(j, grafo, lis, ciudad2, tanqueAuto, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}
	
	
	
	/*
	 * El método caminoConMenorCargaDeCombustible (String ciudad1, String ciudad2,
	 * int tanqueAuto): ListaGenerica<String> // Retorna la lista de ciudades que
	 * forman un camino para llegar de ciudad1 a ciudad2 teniendo en cuenta que el
	 * auto debe cargar la menor cantidad de veces. El auto no se debe quedar sin
	 * combustible en medio de una ruta, además puede completar su tanque al llegar
	 * a cualquier ciudad. Si no existe camino retorna la lista vacía.
	 */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-06 18:11:15.704
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-06 18:11:15.705
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-06 18:11:19.279
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package prog3.grafos.ejercicios;

import prog3.grafos.*;
import prog3.listagenerica.*;
import prog3.util.*;

public class Mapa {

	Grafo<String> mapaCiudades = new GrafoImplListAdy<String>();

	public Mapa(Grafo<String> mapaCiudades) {
		super();
		this.mapaCiudades = mapaCiudades;
	}

	/*
	 * El método devolverCamino (String ciudad1, String ciudad2):
	 * ListaGenerica<String> // Retorna la lista de ciudades que se deben atravesar
	 * para ir de ciudad1 a ciudad2 en caso que se pueda llegar, si no retorna la
	 * lista vacía. (Sin tener en cuenta el combustible).
	 */
	public ListaGenerica<String> devolverCamino(String ciudad1, String ciudad2) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.devolverCamino(i, mapaCiudades, res, ciudad2, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}
	private boolean devolverCamino(int i, Grafo<String> grafo, ListaGenerica<String> lis, String ciudad2,
			boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.devolverCamino(j, grafo, lis, ciudad2, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	
	/*
	 * El método devolverCaminoExceptuando (String ciudad1, String ciudad2,
	 * ListaGenerica<String> ciudades): ListaGenerica<String> // Retorna la lista de
	 * ciudades que forman un camino desde ciudad1 a ciudad2, sin pasar por las
	 * ciudades que están contenidas en la lista ciudades pasada por parámetro, si
	 * no existe camino retorna la lista vacía. (Sin tener en cuenta el
	 * combustible).
	 */
	public ListaGenerica<String> devolverCaminoExceptuando(String ciudad1, String ciudad2,
			ListaGenerica<String> ciudades) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.devolverCaminoExceptuando(i, mapaCiudades, res, ciudades, ciudad2, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}
	private boolean devolverCaminoExceptuando(int i, Grafo<String> grafo, ListaGenerica<String> lis,
			ListaGenerica<String> excepto, String ciudad2, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		excepto.comenzar();
		while (!excepto.fin()) {
			if (v.dato().equals(excepto.proximo())) {
				return false;
			}
		}
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.devolverCaminoExceptuando(j, grafo, lis, excepto, ciudad2, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				marca[i] = false;
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	
	/*
	 * El método caminoMasCorto(String ciudad1, String ciudad2):
	 * ListaGenerica<String> // Retorna la lista de ciudades que forman el camino
	 * más corto para llegar de ciudad1 a ciudad2, si no existe camino retorna la
	 * lista vacía. (Las rutas poseen la distancia). (Sin tener en cuenta el
	 * combustible).
	 */
	public ListaGenericaEnlazada<String> caminoMasCorto(String ciudad1, String ciudad2) {
		ListaGenericaEnlazada<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			this.caminoMinNoPesado(i, mapaCiudades, res, ciudad2);
		}
		return res;
	}
	private void dijkstra(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> lis, String ciudad2) {//Dijkstra(G,w, s){
		ListaGenerica<Arista<String>> ady = null;
		Integer[] D = new Integer[grafo.listaDeVertices().tamanio()];
		Integer[] P = new Integer[grafo.listaDeVertices().tamanio()];
		boolean[] C = new boolean[grafo.listaDeVertices().tamanio()];
		int j, k, l;
		boolean llegue = false;
			
		for (j = 0; j < grafo.listaDeVertices().tamanio(); j++) {//(1) para cada vértice v Є V
			D[j] = null;//(2) Dv = ∞; Pv = 0;
			P[j] = 0;
			C[j] = false;
		}
		D[i] = 0;//(3) Ds = 0;
		for (j=0; j<grafo.listaDeVertices().tamanio() && !llegue; j++) {//(4) para cada vértice v Є V {
			int min = Integer.MAX_VALUE, posMin = 0;
			for (k=0; k<grafo.listaDeVertices().tamanio(); k++) {//(5) u = vérticeDesconocidoMenorDist;
				if ((!C[k]) && (D[k]!=null)) {
					if (D[k]<min) {
						min = D[k];
						posMin = k;
					}
				}
			}
			C[posMin] = true;//(6) Marcar u como conocido;
			Vertice<String> v = grafo.listaDeVertices().elemento(posMin);
			ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			while (!ady.fin()) {//(7) para cada vértice w Є V adyacente a u
				Arista<String> arista = ady.proximo();
				l = arista.verticeDestino().posicion();
				if (!C[l]) {//(8) si (w no está conocido)
					Vertice<String> w = arista.verticeDestino();
					(D[l] > (D[v.posicion()] + arista.peso()));
					P[l] = v.posicion();
					if (arista.verticeDestino().dato().equals(ciudad2)) {
						llegue = true;
						k = j;
						break;
					}
				}
			}
			
		}
		
			
			
			
			
			//(9) si (Dw > Du + c(u,w)) {
			//(10) Dw = Du + c(u,w);
			//(11) Pw = u;
			//(12) }
			//(13) }
			//(14) }
	}// }
	
	private void caminoMinNoPesado(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> lis, String ciudad2) {
		ListaGenerica<Arista<String>> ady = null;
		Integer[] D = new Integer[mapaCiudades.listaDeVertices().tamanio()];
		Integer[] P = new Integer[mapaCiudades.listaDeVertices().tamanio()];
		int j, k = i;
		boolean llegue = false;
		for (j = 0; j < grafo.listaDeVertices().tamanio(); j++) {
			D[j] = null;
			P[j] = 0;
		}
		Cola<Vertice<String>> q = new Cola<Vertice<String>>();
		q.encolar(grafo.listaDeVertices().elemento(i));
		D[i] = 0;
		while (!q.esVacia() && !llegue) {
			Vertice<String> v = q.desencolar();
			ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			while (!ady.fin()) {
				Arista<String> arista = ady.proximo();
				j = arista.verticeDestino().posicion();
				if (D[j] == null) {
					Vertice<String> w = arista.verticeDestino();
					D[j] = D[v.posicion()] + 1;
					P[j] = v.posicion();
					if (arista.verticeDestino().dato().equals(ciudad2)) {
						llegue = true;
						k = j;
						break;
					}
					q.encolar(w);
				}
			}
		}
		if (llegue) {
			int pos = k;
			while (D[pos] != 0) {
				lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
				pos = P[pos];
			}
			lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
		}

	}

	
	/*
	 * El método caminoSinCargarCombustible(String ciudad1, String ciudad2, int
	 * tanqueAuto): ListaGenerica<String> // Retorna la lista de ciudades que forman
	 * un camino para llegar de ciudad1 a ciudad2. El auto no debe quedarse sin
	 * combustible y no puede cargar. Si no existe camino retorna la lista vacía.
	 */
	public ListaGenerica<String> caminoSinCargarCombustible(String ciudad1, String ciudad2, int tanqueAuto) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.caminoSinCargarCombustible(i, mapaCiudades, res, ciudad2, tanqueAuto, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}
	private boolean caminoSinCargarCombustible(int i, Grafo<String> grafo, ListaGenerica<String> lis, String ciudad2, int tanqueAuto, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.caminoSinCargarCombustible(j, grafo, lis, ciudad2, tanqueAuto, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}
	
	
	
	/*
	 * El método caminoConMenorCargaDeCombustible (String ciudad1, String ciudad2,
	 * int tanqueAuto): ListaGenerica<String> // Retorna la lista de ciudades que
	 * forman un camino para llegar de ciudad1 a ciudad2 teniendo en cuenta que el
	 * auto debe cargar la menor cantidad de veces. El auto no se debe quedar sin
	 * combustible en medio de una ruta, además puede completar su tanque al llegar
	 * a cualquier ciudad. Si no existe camino retorna la lista vacía.
	 */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-06 18:11:19.279
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-06 18:11:19.280
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2220)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3034)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2022-06-10 09:58:19.799 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-06-10 09:59:58.158
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-10 09:59:58.158
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@615c4ea4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@417446d9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-10 09:59:58.158
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@34070bd2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1e7d3d87,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-06-10 10:00:08.207
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2022-06-10 10:44:45.349
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package prog3.grafos.ejercicios;

import prog3.grafos.*;
import prog3.listagenerica.*;
import prog3.util.*;

public class Mapa {

	Grafo<String> mapaCiudades = new GrafoImplListAdy<String>();

	public Mapa(Grafo<String> mapaCiudades) {
		super();
		this.mapaCiudades = mapaCiudades;
	}

	/*
	 * El método devolverCamino (String ciudad1, String ciudad2):
	 * ListaGenerica<String> // Retorna la lista de ciudades que se deben atravesar
	 * para ir de ciudad1 a ciudad2 en caso que se pueda llegar, si no retorna la
	 * lista vacía. (Sin tener en cuenta el combustible).
	 */
	public ListaGenerica<String> devolverCamino(String ciudad1, String ciudad2) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.devolverCamino(i, mapaCiudades, res, ciudad2, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}

	private boolean devolverCamino(int i, Grafo<String> grafo, ListaGenerica<String> lis, String ciudad2,
			boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.devolverCamino(j, grafo, lis, ciudad2, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	/*
	 * El método devolverCaminoExceptuando (String ciudad1, String ciudad2,
	 * ListaGenerica<String> ciudades): ListaGenerica<String> // Retorna la lista de
	 * ciudades que forman un camino desde ciudad1 a ciudad2, sin pasar por las
	 * ciudades que están contenidas en la lista ciudades pasada por parámetro, si
	 * no existe camino retorna la lista vacía. (Sin tener en cuenta el
	 * combustible).
	 */
	public ListaGenerica<String> devolverCaminoExceptuando(String ciudad1, String ciudad2,
			ListaGenerica<String> ciudades) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.devolverCaminoExceptuando(i, mapaCiudades, res, ciudades, ciudad2, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}

	private boolean devolverCaminoExceptuando(int i, Grafo<String> grafo, ListaGenerica<String> lis,
			ListaGenerica<String> excepto, String ciudad2, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		excepto.comenzar();
		while (!excepto.fin()) {
			if (v.dato().equals(excepto.proximo())) {
				return false;
			}
		}
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.devolverCaminoExceptuando(j, grafo, lis, excepto, ciudad2, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				marca[i] = false;
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	/*
	 * El método caminoMasCorto(String ciudad1, String ciudad2):
	 * ListaGenerica<String> // Retorna la lista de ciudades que forman el camino
	 * más corto para llegar de ciudad1 a ciudad2, si no existe camino retorna la
	 * lista vacía. (Las rutas poseen la distancia). (Sin tener en cuenta el
	 * combustible).
	 */
	public ListaGenericaEnlazada<String> caminoMasCorto(String ciudad1, String ciudad2) {
		ListaGenericaEnlazada<String> res = new ListaGenericaEnlazada<String>();
		ListaGenericaEnlazada<String> lis = new ListaGenericaEnlazada<String>();
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		Peso min = new Peso();
		min.minimo();
		int peso = 0;
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			this.caminoMasCorto(i, mapaCiudades, res, min, lis, peso, ciudad2, marca);
		}
		return res;
	}

	private void caminoMasCorto(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> res, Peso min,
			ListaGenericaEnlazada<String> lis, int peso, String ciudad2, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			if (peso < min.peso) {
				res.comenzar();
				while(!res.esVacia()) {
					res.eliminarEn(0);
				}
				lis.comenzar();
				while (!lis.fin()) {
					res.agregarFinal(lis.proximo());
				}
				min.peso = peso;
			}
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			Arista<String> arista;
			ady.comenzar();
			while (!ady.fin()) {
				arista = ady.proximo();
				int j = arista.verticeDestino().posicion();
				if (!marca[j]) {
					this.caminoMasCorto(j, grafo, res, min, lis, peso + arista.peso(), ciudad2, marca);
				}
			}
		}
		lis.eliminarEn(lis.tamanio() - 1);
		marca[i] = false;
	}

	private void dijkstra(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> lis, String ciudad2) {// Dijkstra(G,w,
																											// s){
		ListaGenerica<Arista<String>> ady = null;
		Integer[] D = new Integer[grafo.listaDeVertices().tamanio()];
		Integer[] P = new Integer[grafo.listaDeVertices().tamanio()];
		boolean[] C = new boolean[grafo.listaDeVertices().tamanio()];
		int j, k = i, l;
		boolean llegue = false;
		for (j = 0; j < grafo.listaDeVertices().tamanio(); j++) {// (1) para cada vértice v Є V
			D[j] = null;// (2) Dv = ∞; Pv = 0;
			P[j] = 0;
			C[j] = false;
		}
		D[i] = 0;// (3) Ds = 0;
		for (j = 0; j < grafo.listaDeVertices().tamanio() && !llegue; j++) {// (4) para cada vértice v Є V {
			int min = Integer.MAX_VALUE, posMin = 0;
			for (k = 0; k < grafo.listaDeVertices().tamanio(); k++) {// (5) u = vérticeDesconocidoMenorDist;
				if ((!C[k]) && (D[k] != null)) {
					if (D[k] < min) {
						min = D[k];
						posMin = k;
					}
				}
			}
			C[posMin] = true;// (6) Marcar u como conocido;
			Vertice<String> v = grafo.listaDeVertices().elemento(posMin);
			ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			while (!ady.fin()) {// (7) para cada vértice w Є V adyacente a u
				Arista<String> arista = ady.proximo();
				l = arista.verticeDestino().posicion();
				if (!C[l]) {// (8) si (w no está conocido)
					Vertice<String> w = arista.verticeDestino();
					if (D[l] > (D[v.posicion()] + arista.peso())) {// (9) si (Dw > Du + c(u,w)) {
						D[l] = (D[v.posicion()] + arista.peso());// (10) Dw = Du + c(u,w);
						P[l] = v.posicion();// (11) Pw = u;
					}
					if (arista.verticeDestino().dato().equals(ciudad2)) {
						llegue = true;
						k = j;
						break;
					}
				}
			}
		}
		if (llegue) {
			int pos = k;
			while (D[pos] != 0) {
				lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
				pos = P[pos];
			}
			lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
		}
	}

	private void caminoMinNoPesado(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> lis, String ciudad2) {
		ListaGenerica<Arista<String>> ady = null;
		Integer[] D = new Integer[mapaCiudades.listaDeVertices().tamanio()];
		Integer[] P = new Integer[mapaCiudades.listaDeVertices().tamanio()];
		int j, k = i;
		boolean llegue = false;
		for (j = 0; j < grafo.listaDeVertices().tamanio(); j++) {
			D[j] = null;
			P[j] = 0;
		}
		Cola<Vertice<String>> q = new Cola<Vertice<String>>();
		q.encolar(grafo.listaDeVertices().elemento(i));
		D[i] = 0;
		while (!q.esVacia() && !llegue) {
			Vertice<String> v = q.desencolar();
			ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			while (!ady.fin()) {
				Arista<String> arista = ady.proximo();
				j = arista.verticeDestino().posicion();
				if (D[j] == null) {
					Vertice<String> w = arista.verticeDestino();
					D[j] = D[v.posicion()] + 1;
					P[j] = v.posicion();
					if (arista.verticeDestino().dato().equals(ciudad2)) {
						llegue = true;
						k = j;
						break;
					}
					q.encolar(w);
				}
			}
		}
		if (llegue) {
			int pos = k;
			while (D[pos] != 0) {
				lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
				pos = P[pos];
			}
			lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
		}

	}

	/*
	 * El método caminoSinCargarCombustible(String ciudad1, String ciudad2, int
	 * tanqueAuto): ListaGenerica<String> // Retorna la lista de ciudades que forman
	 * un camino para llegar de ciudad1 a ciudad2. El auto no debe quedarse sin
	 * combustible y no puede cargar. Si no existe camino retorna la lista vacía.
	 */
	public ListaGenerica<String> caminoSinCargarCombustible(String ciudad1, String ciudad2, int tanqueAuto) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.caminoSinCargarCombustible(i, mapaCiudades, res, ciudad2, tanqueAuto, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}

	private boolean caminoSinCargarCombustible(int i, Grafo<String> grafo, ListaGenerica<String> lis, String ciudad2,
			int tanqueAuto, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				Arista>
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.caminoSinCargarCombustible(j, grafo, lis, ciudad2, tanqueAuto, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	/*
	 * El método caminoConMenorCargaDeCombustible (String ciudad1, String ciudad2,
	 * int tanqueAuto): ListaGenerica<String> // Retorna la lista de ciudades que
	 * forman un camino para llegar de ciudad1 a ciudad2 teniendo en cuenta que el
	 * auto debe cargar la menor cantidad de veces. El auto no se debe quedar sin
	 * combustible en medio de una ruta, además puede completar su tanque al llegar
	 * a cualquier ciudad. Si no existe camino retorna la lista vacía.
	 */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-06-10 10:44:45.351
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-06-10 10:44:45.352
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
!SESSION 2022-06-10 18:02:54.529 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-06-10 18:04:14.438
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-10 18:04:14.438
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@34070bd2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1e7d3d87,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-10 18:04:14.438
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1dd76982,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7e76a66f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-06-10 18:04:24.190
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2022-06-10 18:30:15.406
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package prog3.grafos.ejercicios;

import prog3.grafos.*;
import prog3.listagenerica.*;
import prog3.util.*;

public class Mapa {

	Grafo<String> mapaCiudades = new GrafoImplListAdy<String>();

	public Mapa(Grafo<String> mapaCiudades) {
		super();
		this.mapaCiudades = mapaCiudades;
	}

	/*
	 * El método devolverCamino (String ciudad1, String ciudad2):
	 * ListaGenerica<String> // Retorna la lista de ciudades que se deben atravesar
	 * para ir de ciudad1 a ciudad2 en caso que se pueda llegar, si no retorna la
	 * lista vacía. (Sin tener en cuenta el combustible).
	 */
	public ListaGenerica<String> devolverCamino(String ciudad1, String ciudad2) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.devolverCamino(i, mapaCiudades, res, ciudad2, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}

	private boolean devolverCamino(int i, Grafo<String> grafo, ListaGenerica<String> lis, String ciudad2,
			boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.devolverCamino(j, grafo, lis, ciudad2, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	/*
	 * El método devolverCaminoExceptuando (String ciudad1, String ciudad2,
	 * ListaGenerica<String> ciudades): ListaGenerica<String> // Retorna la lista de
	 * ciudades que forman un camino desde ciudad1 a ciudad2, sin pasar por las
	 * ciudades que están contenidas en la lista ciudades pasada por parámetro, si
	 * no existe camino retorna la lista vacía. (Sin tener en cuenta el
	 * combustible).
	 */
	public ListaGenerica<String> devolverCaminoExceptuando(String ciudad1, String ciudad2,
			ListaGenerica<String> ciudades) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.devolverCaminoExceptuando(i, mapaCiudades, res, ciudades, ciudad2, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}

	private boolean devolverCaminoExceptuando(int i, Grafo<String> grafo, ListaGenerica<String> lis,
			ListaGenerica<String> excepto, String ciudad2, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		excepto.comenzar();
		while (!excepto.fin()) {
			if (v.dato().equals(excepto.proximo())) {
				return false;
			}
		}
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.devolverCaminoExceptuando(j, grafo, lis, excepto, ciudad2, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				marca[i] = false;
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	/*
	 * El método caminoMasCorto(String ciudad1, String ciudad2):
	 * ListaGenerica<String> // Retorna la lista de ciudades que forman el camino
	 * más corto para llegar de ciudad1 a ciudad2, si no existe camino retorna la
	 * lista vacía. (Las rutas poseen la distancia). (Sin tener en cuenta el
	 * combustible).
	 */
	public ListaGenericaEnlazada<String> caminoMasCorto(String ciudad1, String ciudad2) {
		ListaGenericaEnlazada<String> res = new ListaGenericaEnlazada<String>();
		ListaGenericaEnlazada<String> lis = new ListaGenericaEnlazada<String>();
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		Peso min = new Peso();
		min.minimo();
		int peso = 0;
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			this.caminoMasCorto(i, mapaCiudades, res, min, lis, peso, ciudad2, marca);
		}
		return res;
	}

	private void caminoMasCorto(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> res, Peso min,
			ListaGenericaEnlazada<String> lis, int peso, String ciudad2, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			if (peso < min.peso) {
				res.comenzar();
				while (!res.esVacia()) {
					res.eliminarEn(0);
				}
				lis.comenzar();
				while (!lis.fin()) {
					res.agregarFinal(lis.proximo());
				}
				min.peso = peso;
			}
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			Arista<String> arista;
			ady.comenzar();
			while (!ady.fin()) {
				arista = ady.proximo();
				int j = arista.verticeDestino().posicion();
				if (!marca[j]) {
					this.caminoMasCorto(j, grafo, res, min, lis, peso + arista.peso(), ciudad2, marca);
				}
			}
		}
		lis.eliminarEn(lis.tamanio() - 1);
		marca[i] = false;
	}

	private void dijkstra(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> lis, String ciudad2) {// Dijkstra(G,w,
																											// s){
		ListaGenerica<Arista<String>> ady = null;
		Integer[] D = new Integer[grafo.listaDeVertices().tamanio()];
		Integer[] P = new Integer[grafo.listaDeVertices().tamanio()];
		boolean[] C = new boolean[grafo.listaDeVertices().tamanio()];
		int j, k = i, l;
		boolean llegue = false;
		for (j = 0; j < grafo.listaDeVertices().tamanio(); j++) {// (1) para cada vértice v Є V
			D[j] = null;// (2) Dv = ∞; Pv = 0;
			P[j] = 0;
			C[j] = false;
		}
		D[i] = 0;// (3) Ds = 0;
		for (j = 0; j < grafo.listaDeVertices().tamanio() && !llegue; j++) {// (4) para cada vértice v Є V {
			int min = Integer.MAX_VALUE, posMin = 0;
			for (k = 0; k < grafo.listaDeVertices().tamanio(); k++) {// (5) u = vérticeDesconocidoMenorDist;
				if ((!C[k]) && (D[k] != null)) {
					if (D[k] < min) {
						min = D[k];
						posMin = k;
					}
				}
			}
			C[posMin] = true;// (6) Marcar u como conocido;
			Vertice<String> v = grafo.listaDeVertices().elemento(posMin);
			ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			while (!ady.fin()) {// (7) para cada vértice w Є V adyacente a u
				Arista<String> arista = ady.proximo();
				l = arista.verticeDestino().posicion();
				if (!C[l]) {// (8) si (w no está conocido)
					Vertice<String> w = arista.verticeDestino();
					if (D[l] > (D[v.posicion()] + arista.peso())) {// (9) si (Dw > Du + c(u,w)) {
						D[l] = (D[v.posicion()] + arista.peso());// (10) Dw = Du + c(u,w);
						P[l] = v.posicion();// (11) Pw = u;
					}
					if (arista.verticeDestino().dato().equals(ciudad2)) {
						llegue = true;
						k = j;
						break;
					}
				}
			}
		}
		if (llegue) {
			int pos = k;
			while (D[pos] != 0) {
				lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
				pos = P[pos];
			}
			lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
		}
	}

	private void caminoMinNoPesado(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> lis, String ciudad2) {
		ListaGenerica<Arista<String>> ady = null;
		Integer[] D = new Integer[mapaCiudades.listaDeVertices().tamanio()];
		Integer[] P = new Integer[mapaCiudades.listaDeVertices().tamanio()];
		int j, k = i;
		boolean llegue = false;
		for (j = 0; j < grafo.listaDeVertices().tamanio(); j++) {
			D[j] = null;
			P[j] = 0;
		}
		Cola<Vertice<String>> q = new Cola<Vertice<String>>();
		q.encolar(grafo.listaDeVertices().elemento(i));
		D[i] = 0;
		while (!q.esVacia() && !llegue) {
			Vertice<String> v = q.desencolar();
			ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			while (!ady.fin()) {
				Arista<String> arista = ady.proximo();
				j = arista.verticeDestino().posicion();
				if (D[j] == null) {
					Vertice<String> w = arista.verticeDestino();
					D[j] = D[v.posicion()] + 1;
					P[j] = v.posicion();
					if (arista.verticeDestino().dato().equals(ciudad2)) {
						llegue = true;
						k = j;
						break;
					}
					q.encolar(w);
				}
			}
		}
		if (llegue) {
			int pos = k;
			while (D[pos] != 0) {
				lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
				pos = P[pos];
			}
			lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
		}

	}

	/*
	 * El método caminoSinCargarCombustible(String ciudad1, String ciudad2, int
	 * tanqueAuto): ListaGenerica<String> // Retorna la lista de ciudades que forman
	 * un camino para llegar de ciudad1 a ciudad2. El auto no debe quedarse sin
	 * combustible y no puede cargar. Si no existe camino retorna la lista vacía.
	 */
	public ListaGenerica<String> caminoSinCargarCombustible(String ciudad1, String ciudad2, int tanqueAuto) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.caminoSinCargarCombustible(i, mapaCiudades, res, ciudad2, tanqueAuto, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}

	private boolean caminoSinCargarCombustible(int i, Grafo<String> grafo, ListaGenerica<String> lis, String ciudad2,
			int tanqueAuto, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				Arista<String> arista = ady.proximo();
				if ((tanqueAuto - arista.peso()) >= 0) {
					int j = arista.verticeDestino().posicion();
					if (!marca[j]) {
						llegue = this.caminoSinCargarCombustible(j, grafo, lis, ciudad2, tanqueAuto - arista.peso(),
								marca);
					}
				}
			}
			if (llegue) {
				return true;
			} else {
				marca[i] = false;
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	/*
	 * El método caminoConMenorCargaDeCombustible (String ciudad1, String ciudad2,
	 * int tanqueAuto): ListaGenerica<String> // Retorna la lista de ciudades que
	 * forman un camino para llegar de ciudad1 a ciudad2 teniendo en cuenta que el
	 * auto debe cargar la menor cantidad de veces. El auto no se debe quedar sin
	 * combustible en medio de una ruta, además puede completar su tanque al llegar
	 * a cualquier ciudad. Si no existe camino retorna la lista vacía.
	 */
	public ListaGenericaEnlazada<String> caminoConMenorCargaDeCombustible(String ciudad1, String ciudad2,
			int tanqueAuto) {
		ListaGenericaEnlazada<String> res = new ListaGenericaEnlazada<String>();
		ListaGenericaEnlazada<String> lis = new ListaGenericaEnlazada<String>();
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		Peso min = new Peso();
		min.minimo();
		int peso = 0;
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			this.caminoConMenorCargaDeCombustible(i, mapaCiudades, res, min, lis, peso, tanqueAuto, tanqueAuto, ciudad2,
					marca);
		}
		return res;
	}

	private void caminoConMenorCargaDeCombustible(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> res,
			Peso min, ListaGenericaEnlazada<String> lis, int peso, int tanqueAuto, int lleno, String ciudad2,
			boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			if (peso < min.peso) {
				res.comenzar();
				while (!res.esVacia()) {
					res.eliminarEn(0);
				}
				lis.comenzar();
				while (!lis.fin()) {
					res.agregarFinal(lis.proximo());
				}
				min.peso = peso;
			}
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			Arista<String> arista;
			ady.comenzar();
			while (!ady.fin()) {
				arista = ady.proximo();
				int j = arista.verticeDestino().posicion();
				if ((tanqueAuto - arista.peso()) >= 0) ((tanqueAuto - arista.peso()) >= 0) {
					if (!marca[j]) {
						this.caminoConMenorCargaDeCombustible(j, grafo, res, min, lis, peso + 1, lleno - arista.peso(),
								lleno, ciudad2, marca);
					}
				} else {
					if (!marca[j]) {
						this.caminoConMenorCargaDeCombustible(j, grafo, res, min, lis, peso, tanqueAuto - arista.peso(),
								lleno, ciudad2, marca);
					}
				}

			}
		}
		lis.eliminarEn(lis.tamanio() - 1);
		marca[i] = false;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-06-10 18:30:15.412
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-06-10 18:30:15.414
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-10 18:30:15.451
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package prog3.grafos.ejercicios;

import prog3.grafos.*;
import prog3.listagenerica.*;
import prog3.util.*;

public class Mapa {

	Grafo<String> mapaCiudades = new GrafoImplListAdy<String>();

	public Mapa(Grafo<String> mapaCiudades) {
		super();
		this.mapaCiudades = mapaCiudades;
	}

	/*
	 * El método devolverCamino (String ciudad1, String ciudad2):
	 * ListaGenerica<String> // Retorna la lista de ciudades que se deben atravesar
	 * para ir de ciudad1 a ciudad2 en caso que se pueda llegar, si no retorna la
	 * lista vacía. (Sin tener en cuenta el combustible).
	 */
	public ListaGenerica<String> devolverCamino(String ciudad1, String ciudad2) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.devolverCamino(i, mapaCiudades, res, ciudad2, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}

	private boolean devolverCamino(int i, Grafo<String> grafo, ListaGenerica<String> lis, String ciudad2,
			boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.devolverCamino(j, grafo, lis, ciudad2, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	/*
	 * El método devolverCaminoExceptuando (String ciudad1, String ciudad2,
	 * ListaGenerica<String> ciudades): ListaGenerica<String> // Retorna la lista de
	 * ciudades que forman un camino desde ciudad1 a ciudad2, sin pasar por las
	 * ciudades que están contenidas en la lista ciudades pasada por parámetro, si
	 * no existe camino retorna la lista vacía. (Sin tener en cuenta el
	 * combustible).
	 */
	public ListaGenerica<String> devolverCaminoExceptuando(String ciudad1, String ciudad2,
			ListaGenerica<String> ciudades) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.devolverCaminoExceptuando(i, mapaCiudades, res, ciudades, ciudad2, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}

	private boolean devolverCaminoExceptuando(int i, Grafo<String> grafo, ListaGenerica<String> lis,
			ListaGenerica<String> excepto, String ciudad2, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		excepto.comenzar();
		while (!excepto.fin()) {
			if (v.dato().equals(excepto.proximo())) {
				return false;
			}
		}
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.devolverCaminoExceptuando(j, grafo, lis, excepto, ciudad2, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				marca[i] = false;
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	/*
	 * El método caminoMasCorto(String ciudad1, String ciudad2):
	 * ListaGenerica<String> // Retorna la lista de ciudades que forman el camino
	 * más corto para llegar de ciudad1 a ciudad2, si no existe camino retorna la
	 * lista vacía. (Las rutas poseen la distancia). (Sin tener en cuenta el
	 * combustible).
	 */
	public ListaGenericaEnlazada<String> caminoMasCorto(String ciudad1, String ciudad2) {
		ListaGenericaEnlazada<String> res = new ListaGenericaEnlazada<String>();
		ListaGenericaEnlazada<String> lis = new ListaGenericaEnlazada<String>();
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		Peso min = new Peso();
		min.minimo();
		int peso = 0;
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			this.caminoMasCorto(i, mapaCiudades, res, min, lis, peso, ciudad2, marca);
		}
		return res;
	}

	private void caminoMasCorto(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> res, Peso min,
			ListaGenericaEnlazada<String> lis, int peso, String ciudad2, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			if (peso < min.peso) {
				res.comenzar();
				while (!res.esVacia()) {
					res.eliminarEn(0);
				}
				lis.comenzar();
				while (!lis.fin()) {
					res.agregarFinal(lis.proximo());
				}
				min.peso = peso;
			}
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			Arista<String> arista;
			ady.comenzar();
			while (!ady.fin()) {
				arista = ady.proximo();
				int j = arista.verticeDestino().posicion();
				if (!marca[j]) {
					this.caminoMasCorto(j, grafo, res, min, lis, peso + arista.peso(), ciudad2, marca);
				}
			}
		}
		lis.eliminarEn(lis.tamanio() - 1);
		marca[i] = false;
	}

	private void dijkstra(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> lis, String ciudad2) {// Dijkstra(G,w,
																											// s){
		ListaGenerica<Arista<String>> ady = null;
		Integer[] D = new Integer[grafo.listaDeVertices().tamanio()];
		Integer[] P = new Integer[grafo.listaDeVertices().tamanio()];
		boolean[] C = new boolean[grafo.listaDeVertices().tamanio()];
		int j, k = i, l;
		boolean llegue = false;
		for (j = 0; j < grafo.listaDeVertices().tamanio(); j++) {// (1) para cada vértice v Є V
			D[j] = null;// (2) Dv = ∞; Pv = 0;
			P[j] = 0;
			C[j] = false;
		}
		D[i] = 0;// (3) Ds = 0;
		for (j = 0; j < grafo.listaDeVertices().tamanio() && !llegue; j++) {// (4) para cada vértice v Є V {
			int min = Integer.MAX_VALUE, posMin = 0;
			for (k = 0; k < grafo.listaDeVertices().tamanio(); k++) {// (5) u = vérticeDesconocidoMenorDist;
				if ((!C[k]) && (D[k] != null)) {
					if (D[k] < min) {
						min = D[k];
						posMin = k;
					}
				}
			}
			C[posMin] = true;// (6) Marcar u como conocido;
			Vertice<String> v = grafo.listaDeVertices().elemento(posMin);
			ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			while (!ady.fin()) {// (7) para cada vértice w Є V adyacente a u
				Arista<String> arista = ady.proximo();
				l = arista.verticeDestino().posicion();
				if (!C[l]) {// (8) si (w no está conocido)
					Vertice<String> w = arista.verticeDestino();
					if (D[l] > (D[v.posicion()] + arista.peso())) {// (9) si (Dw > Du + c(u,w)) {
						D[l] = (D[v.posicion()] + arista.peso());// (10) Dw = Du + c(u,w);
						P[l] = v.posicion();// (11) Pw = u;
					}
					if (arista.verticeDestino().dato().equals(ciudad2)) {
						llegue = true;
						k = j;
						break;
					}
				}
			}
		}
		if (llegue) {
			int pos = k;
			while (D[pos] != 0) {
				lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
				pos = P[pos];
			}
			lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
		}
	}

	private void caminoMinNoPesado(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> lis, String ciudad2) {
		ListaGenerica<Arista<String>> ady = null;
		Integer[] D = new Integer[mapaCiudades.listaDeVertices().tamanio()];
		Integer[] P = new Integer[mapaCiudades.listaDeVertices().tamanio()];
		int j, k = i;
		boolean llegue = false;
		for (j = 0; j < grafo.listaDeVertices().tamanio(); j++) {
			D[j] = null;
			P[j] = 0;
		}
		Cola<Vertice<String>> q = new Cola<Vertice<String>>();
		q.encolar(grafo.listaDeVertices().elemento(i));
		D[i] = 0;
		while (!q.esVacia() && !llegue) {
			Vertice<String> v = q.desencolar();
			ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			while (!ady.fin()) {
				Arista<String> arista = ady.proximo();
				j = arista.verticeDestino().posicion();
				if (D[j] == null) {
					Vertice<String> w = arista.verticeDestino();
					D[j] = D[v.posicion()] + 1;
					P[j] = v.posicion();
					if (arista.verticeDestino().dato().equals(ciudad2)) {
						llegue = true;
						k = j;
						break;
					}
					q.encolar(w);
				}
			}
		}
		if (llegue) {
			int pos = k;
			while (D[pos] != 0) {
				lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
				pos = P[pos];
			}
			lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
		}

	}

	/*
	 * El método caminoSinCargarCombustible(String ciudad1, String ciudad2, int
	 * tanqueAuto): ListaGenerica<String> // Retorna la lista de ciudades que forman
	 * un camino para llegar de ciudad1 a ciudad2. El auto no debe quedarse sin
	 * combustible y no puede cargar. Si no existe camino retorna la lista vacía.
	 */
	public ListaGenerica<String> caminoSinCargarCombustible(String ciudad1, String ciudad2, int tanqueAuto) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.caminoSinCargarCombustible(i, mapaCiudades, res, ciudad2, tanqueAuto, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}

	private boolean caminoSinCargarCombustible(int i, Grafo<String> grafo, ListaGenerica<String> lis, String ciudad2,
			int tanqueAuto, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				Arista<String> arista = ady.proximo();
				if ((tanqueAuto - arista.peso()) >= 0) {
					int j = arista.verticeDestino().posicion();
					if (!marca[j]) {
						llegue = this.caminoSinCargarCombustible(j, grafo, lis, ciudad2, tanqueAuto - arista.peso(),
								marca);
					}
				}
			}
			if (llegue) {
				return true;
			} else {
				marca[i] = false;
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	/*
	 * El método caminoConMenorCargaDeCombustible (String ciudad1, String ciudad2,
	 * int tanqueAuto): ListaGenerica<String> // Retorna la lista de ciudades que
	 * forman un camino para llegar de ciudad1 a ciudad2 teniendo en cuenta que el
	 * auto debe cargar la menor cantidad de veces. El auto no se debe quedar sin
	 * combustible en medio de una ruta, además puede completar su tanque al llegar
	 * a cualquier ciudad. Si no existe camino retorna la lista vacía.
	 */
	public ListaGenericaEnlazada<String> caminoConMenorCargaDeCombustible(String ciudad1, String ciudad2,
			int tanqueAuto) {
		ListaGenericaEnlazada<String> res = new ListaGenericaEnlazada<String>();
		ListaGenericaEnlazada<String> lis = new ListaGenericaEnlazada<String>();
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		Peso min = new Peso();
		min.minimo();
		int peso = 0;
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			this.caminoConMenorCargaDeCombustible(i, mapaCiudades, res, min, lis, peso, tanqueAuto, tanqueAuto, ciudad2,
					marca);
		}
		return res;
	}

	private void caminoConMenorCargaDeCombustible(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> res,
			Peso min, ListaGenericaEnlazada<String> lis, int peso, int tanqueAuto, int lleno, String ciudad2,
			boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			if (peso < min.peso) {
				res.comenzar();
				while (!res.esVacia()) {
					res.eliminarEn(0);
				}
				lis.comenzar();
				while (!lis.fin()) {
					res.agregarFinal(lis.proximo());
				}
				min.peso = peso;
			}
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			Arista<String> arista;
			ady.comenzar();
			while (!ady.fin()) {
				arista = ady.proximo();
				int j = arista.verticeDestino().posicion();
				if ((tanqueAuto - arista.peso()) >= 0) ((tanqueAuto - arista.peso()) >= 0) {
					if (!marca[j]) {
						this.caminoConMenorCargaDeCombustible(j, grafo, res, min, lis, peso + 1, lleno - arista.peso(),
								lleno, ciudad2, marca);
					}
				} else {
					if (!marca[j]) {
						this.caminoConMenorCargaDeCombustible(j, grafo, res, min, lis, peso, tanqueAuto - arista.peso(),
								lleno, ciudad2, marca);
					}
				}

			}
		}
		lis.eliminarEn(lis.tamanio() - 1);
		marca[i] = false;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-10 18:30:15.454
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-10 18:30:15.456
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-10 18:30:15.482
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package prog3.grafos.ejercicios;

import prog3.grafos.*;
import prog3.listagenerica.*;
import prog3.util.*;

public class Mapa {

	Grafo<String> mapaCiudades = new GrafoImplListAdy<String>();

	public Mapa(Grafo<String> mapaCiudades) {
		super();
		this.mapaCiudades = mapaCiudades;
	}

	/*
	 * El método devolverCamino (String ciudad1, String ciudad2):
	 * ListaGenerica<String> // Retorna la lista de ciudades que se deben atravesar
	 * para ir de ciudad1 a ciudad2 en caso que se pueda llegar, si no retorna la
	 * lista vacía. (Sin tener en cuenta el combustible).
	 */
	public ListaGenerica<String> devolverCamino(String ciudad1, String ciudad2) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.devolverCamino(i, mapaCiudades, res, ciudad2, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}

	private boolean devolverCamino(int i, Grafo<String> grafo, ListaGenerica<String> lis, String ciudad2,
			boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.devolverCamino(j, grafo, lis, ciudad2, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	/*
	 * El método devolverCaminoExceptuando (String ciudad1, String ciudad2,
	 * ListaGenerica<String> ciudades): ListaGenerica<String> // Retorna la lista de
	 * ciudades que forman un camino desde ciudad1 a ciudad2, sin pasar por las
	 * ciudades que están contenidas en la lista ciudades pasada por parámetro, si
	 * no existe camino retorna la lista vacía. (Sin tener en cuenta el
	 * combustible).
	 */
	public ListaGenerica<String> devolverCaminoExceptuando(String ciudad1, String ciudad2,
			ListaGenerica<String> ciudades) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.devolverCaminoExceptuando(i, mapaCiudades, res, ciudades, ciudad2, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}

	private boolean devolverCaminoExceptuando(int i, Grafo<String> grafo, ListaGenerica<String> lis,
			ListaGenerica<String> excepto, String ciudad2, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		excepto.comenzar();
		while (!excepto.fin()) {
			if (v.dato().equals(excepto.proximo())) {
				return false;
			}
		}
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.devolverCaminoExceptuando(j, grafo, lis, excepto, ciudad2, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				marca[i] = false;
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	/*
	 * El método caminoMasCorto(String ciudad1, String ciudad2):
	 * ListaGenerica<String> // Retorna la lista de ciudades que forman el camino
	 * más corto para llegar de ciudad1 a ciudad2, si no existe camino retorna la
	 * lista vacía. (Las rutas poseen la distancia). (Sin tener en cuenta el
	 * combustible).
	 */
	public ListaGenericaEnlazada<String> caminoMasCorto(String ciudad1, String ciudad2) {
		ListaGenericaEnlazada<String> res = new ListaGenericaEnlazada<String>();
		ListaGenericaEnlazada<String> lis = new ListaGenericaEnlazada<String>();
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		Peso min = new Peso();
		min.minimo();
		int peso = 0;
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			this.caminoMasCorto(i, mapaCiudades, res, min, lis, peso, ciudad2, marca);
		}
		return res;
	}

	private void caminoMasCorto(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> res, Peso min,
			ListaGenericaEnlazada<String> lis, int peso, String ciudad2, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			if (peso < min.peso) {
				res.comenzar();
				while (!res.esVacia()) {
					res.eliminarEn(0);
				}
				lis.comenzar();
				while (!lis.fin()) {
					res.agregarFinal(lis.proximo());
				}
				min.peso = peso;
			}
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			Arista<String> arista;
			ady.comenzar();
			while (!ady.fin()) {
				arista = ady.proximo();
				int j = arista.verticeDestino().posicion();
				if (!marca[j]) {
					this.caminoMasCorto(j, grafo, res, min, lis, peso + arista.peso(), ciudad2, marca);
				}
			}
		}
		lis.eliminarEn(lis.tamanio() - 1);
		marca[i] = false;
	}

	private void dijkstra(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> lis, String ciudad2) {// Dijkstra(G,w,
																											// s){
		ListaGenerica<Arista<String>> ady = null;
		Integer[] D = new Integer[grafo.listaDeVertices().tamanio()];
		Integer[] P = new Integer[grafo.listaDeVertices().tamanio()];
		boolean[] C = new boolean[grafo.listaDeVertices().tamanio()];
		int j, k = i, l;
		boolean llegue = false;
		for (j = 0; j < grafo.listaDeVertices().tamanio(); j++) {// (1) para cada vértice v Є V
			D[j] = null;// (2) Dv = ∞; Pv = 0;
			P[j] = 0;
			C[j] = false;
		}
		D[i] = 0;// (3) Ds = 0;
		for (j = 0; j < grafo.listaDeVertices().tamanio() && !llegue; j++) {// (4) para cada vértice v Є V {
			int min = Integer.MAX_VALUE, posMin = 0;
			for (k = 0; k < grafo.listaDeVertices().tamanio(); k++) {// (5) u = vérticeDesconocidoMenorDist;
				if ((!C[k]) && (D[k] != null)) {
					if (D[k] < min) {
						min = D[k];
						posMin = k;
					}
				}
			}
			C[posMin] = true;// (6) Marcar u como conocido;
			Vertice<String> v = grafo.listaDeVertices().elemento(posMin);
			ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			while (!ady.fin()) {// (7) para cada vértice w Є V adyacente a u
				Arista<String> arista = ady.proximo();
				l = arista.verticeDestino().posicion();
				if (!C[l]) {// (8) si (w no está conocido)
					Vertice<String> w = arista.verticeDestino();
					if (D[l] > (D[v.posicion()] + arista.peso())) {// (9) si (Dw > Du + c(u,w)) {
						D[l] = (D[v.posicion()] + arista.peso());// (10) Dw = Du + c(u,w);
						P[l] = v.posicion();// (11) Pw = u;
					}
					if (arista.verticeDestino().dato().equals(ciudad2)) {
						llegue = true;
						k = j;
						break;
					}
				}
			}
		}
		if (llegue) {
			int pos = k;
			while (D[pos] != 0) {
				lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
				pos = P[pos];
			}
			lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
		}
	}

	private void caminoMinNoPesado(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> lis, String ciudad2) {
		ListaGenerica<Arista<String>> ady = null;
		Integer[] D = new Integer[mapaCiudades.listaDeVertices().tamanio()];
		Integer[] P = new Integer[mapaCiudades.listaDeVertices().tamanio()];
		int j, k = i;
		boolean llegue = false;
		for (j = 0; j < grafo.listaDeVertices().tamanio(); j++) {
			D[j] = null;
			P[j] = 0;
		}
		Cola<Vertice<String>> q = new Cola<Vertice<String>>();
		q.encolar(grafo.listaDeVertices().elemento(i));
		D[i] = 0;
		while (!q.esVacia() && !llegue) {
			Vertice<String> v = q.desencolar();
			ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			while (!ady.fin()) {
				Arista<String> arista = ady.proximo();
				j = arista.verticeDestino().posicion();
				if (D[j] == null) {
					Vertice<String> w = arista.verticeDestino();
					D[j] = D[v.posicion()] + 1;
					P[j] = v.posicion();
					if (arista.verticeDestino().dato().equals(ciudad2)) {
						llegue = true;
						k = j;
						break;
					}
					q.encolar(w);
				}
			}
		}
		if (llegue) {
			int pos = k;
			while (D[pos] != 0) {
				lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
				pos = P[pos];
			}
			lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
		}

	}

	/*
	 * El método caminoSinCargarCombustible(String ciudad1, String ciudad2, int
	 * tanqueAuto): ListaGenerica<String> // Retorna la lista de ciudades que forman
	 * un camino para llegar de ciudad1 a ciudad2. El auto no debe quedarse sin
	 * combustible y no puede cargar. Si no existe camino retorna la lista vacía.
	 */
	public ListaGenerica<String> caminoSinCargarCombustible(String ciudad1, String ciudad2, int tanqueAuto) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.caminoSinCargarCombustible(i, mapaCiudades, res, ciudad2, tanqueAuto, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}

	private boolean caminoSinCargarCombustible(int i, Grafo<String> grafo, ListaGenerica<String> lis, String ciudad2,
			int tanqueAuto, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				Arista<String> arista = ady.proximo();
				if ((tanqueAuto - arista.peso()) >= 0) {
					int j = arista.verticeDestino().posicion();
					if (!marca[j]) {
						llegue = this.caminoSinCargarCombustible(j, grafo, lis, ciudad2, tanqueAuto - arista.peso(),
								marca);
					}
				}
			}
			if (llegue) {
				return true;
			} else {
				marca[i] = false;
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	/*
	 * El método caminoConMenorCargaDeCombustible (String ciudad1, String ciudad2,
	 * int tanqueAuto): ListaGenerica<String> // Retorna la lista de ciudades que
	 * forman un camino para llegar de ciudad1 a ciudad2 teniendo en cuenta que el
	 * auto debe cargar la menor cantidad de veces. El auto no se debe quedar sin
	 * combustible en medio de una ruta, además puede completar su tanque al llegar
	 * a cualquier ciudad. Si no existe camino retorna la lista vacía.
	 */
	public ListaGenericaEnlazada<String> caminoConMenorCargaDeCombustible(String ciudad1, String ciudad2,
			int tanqueAuto) {
		ListaGenericaEnlazada<String> res = new ListaGenericaEnlazada<String>();
		ListaGenericaEnlazada<String> lis = new ListaGenericaEnlazada<String>();
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		Peso min = new Peso();
		min.minimo();
		int peso = 0;
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			this.caminoConMenorCargaDeCombustible(i, mapaCiudades, res, min, lis, peso, tanqueAuto, tanqueAuto, ciudad2,
					marca);
		}
		return res;
	}

	private void caminoConMenorCargaDeCombustible(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> res,
			Peso min, ListaGenericaEnlazada<String> lis, int peso, int tanqueAuto, int lleno, String ciudad2,
			boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			if (peso < min.peso) {
				res.comenzar();
				while (!res.esVacia()) {
					res.eliminarEn(0);
				}
				lis.comenzar();
				while (!lis.fin()) {
					res.agregarFinal(lis.proximo());
				}
				min.peso = peso;
			}
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			Arista<String> arista;
			ady.comenzar();
			while (!ady.fin()) {
				arista = ady.proximo();
				int j = arista.verticeDestino().posicion();
				if ((tanqueAuto - arista.peso()) >= 0) ((tanqueAuto - arista.peso()) >= 0) {
					if (!marca[j]) {
						this.caminoConMenorCargaDeCombustible(j, grafo, res, min, lis, peso + 1, lleno - arista.peso(),
								lleno, ciudad2, marca);
					}
				} else {
					if (!marca[j]) {
						this.caminoConMenorCargaDeCombustible(j, grafo, res, min, lis, peso, tanqueAuto - arista.peso(),
								lleno, ciudad2, marca);
					}
				}

			}
		}
		lis.eliminarEn(lis.tamanio() - 1);
		marca[i] = false;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-10 18:30:15.483
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-10 18:30:15.485
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-10 18:30:15.807
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package prog3.grafos.ejercicios;

import prog3.grafos.*;
import prog3.listagenerica.*;
import prog3.util.*;

public class Mapa {

	Grafo<String> mapaCiudades = new GrafoImplListAdy<String>();

	public Mapa(Grafo<String> mapaCiudades) {
		super();
		this.mapaCiudades = mapaCiudades;
	}

	/*
	 * El método devolverCamino (String ciudad1, String ciudad2):
	 * ListaGenerica<String> // Retorna la lista de ciudades que se deben atravesar
	 * para ir de ciudad1 a ciudad2 en caso que se pueda llegar, si no retorna la
	 * lista vacía. (Sin tener en cuenta el combustible).
	 */
	public ListaGenerica<String> devolverCamino(String ciudad1, String ciudad2) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.devolverCamino(i, mapaCiudades, res, ciudad2, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}

	private boolean devolverCamino(int i, Grafo<String> grafo, ListaGenerica<String> lis, String ciudad2,
			boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.devolverCamino(j, grafo, lis, ciudad2, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	/*
	 * El método devolverCaminoExceptuando (String ciudad1, String ciudad2,
	 * ListaGenerica<String> ciudades): ListaGenerica<String> // Retorna la lista de
	 * ciudades que forman un camino desde ciudad1 a ciudad2, sin pasar por las
	 * ciudades que están contenidas en la lista ciudades pasada por parámetro, si
	 * no existe camino retorna la lista vacía. (Sin tener en cuenta el
	 * combustible).
	 */
	public ListaGenerica<String> devolverCaminoExceptuando(String ciudad1, String ciudad2,
			ListaGenerica<String> ciudades) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.devolverCaminoExceptuando(i, mapaCiudades, res, ciudades, ciudad2, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}

	private boolean devolverCaminoExceptuando(int i, Grafo<String> grafo, ListaGenerica<String> lis,
			ListaGenerica<String> excepto, String ciudad2, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		excepto.comenzar();
		while (!excepto.fin()) {
			if (v.dato().equals(excepto.proximo())) {
				return false;
			}
		}
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.devolverCaminoExceptuando(j, grafo, lis, excepto, ciudad2, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				marca[i] = false;
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	/*
	 * El método caminoMasCorto(String ciudad1, String ciudad2):
	 * ListaGenerica<String> // Retorna la lista de ciudades que forman el camino
	 * más corto para llegar de ciudad1 a ciudad2, si no existe camino retorna la
	 * lista vacía. (Las rutas poseen la distancia). (Sin tener en cuenta el
	 * combustible).
	 */
	public ListaGenericaEnlazada<String> caminoMasCorto(String ciudad1, String ciudad2) {
		ListaGenericaEnlazada<String> res = new ListaGenericaEnlazada<String>();
		ListaGenericaEnlazada<String> lis = new ListaGenericaEnlazada<String>();
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		Peso min = new Peso();
		min.minimo();
		int peso = 0;
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			this.caminoMasCorto(i, mapaCiudades, res, min, lis, peso, ciudad2, marca);
		}
		return res;
	}

	private void caminoMasCorto(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> res, Peso min,
			ListaGenericaEnlazada<String> lis, int peso, String ciudad2, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			if (peso < min.peso) {
				res.comenzar();
				while (!res.esVacia()) {
					res.eliminarEn(0);
				}
				lis.comenzar();
				while (!lis.fin()) {
					res.agregarFinal(lis.proximo());
				}
				min.peso = peso;
			}
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			Arista<String> arista;
			ady.comenzar();
			while (!ady.fin()) {
				arista = ady.proximo();
				int j = arista.verticeDestino().posicion();
				if (!marca[j]) {
					this.caminoMasCorto(j, grafo, res, min, lis, peso + arista.peso(), ciudad2, marca);
				}
			}
		}
		lis.eliminarEn(lis.tamanio() - 1);
		marca[i] = false;
	}

	private void dijkstra(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> lis, String ciudad2) {// Dijkstra(G,w,
																											// s){
		ListaGenerica<Arista<String>> ady = null;
		Integer[] D = new Integer[grafo.listaDeVertices().tamanio()];
		Integer[] P = new Integer[grafo.listaDeVertices().tamanio()];
		boolean[] C = new boolean[grafo.listaDeVertices().tamanio()];
		int j, k = i, l;
		boolean llegue = false;
		for (j = 0; j < grafo.listaDeVertices().tamanio(); j++) {// (1) para cada vértice v Є V
			D[j] = null;// (2) Dv = ∞; Pv = 0;
			P[j] = 0;
			C[j] = false;
		}
		D[i] = 0;// (3) Ds = 0;
		for (j = 0; j < grafo.listaDeVertices().tamanio() && !llegue; j++) {// (4) para cada vértice v Є V {
			int min = Integer.MAX_VALUE, posMin = 0;
			for (k = 0; k < grafo.listaDeVertices().tamanio(); k++) {// (5) u = vérticeDesconocidoMenorDist;
				if ((!C[k]) && (D[k] != null)) {
					if (D[k] < min) {
						min = D[k];
						posMin = k;
					}
				}
			}
			C[posMin] = true;// (6) Marcar u como conocido;
			Vertice<String> v = grafo.listaDeVertices().elemento(posMin);
			ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			while (!ady.fin()) {// (7) para cada vértice w Є V adyacente a u
				Arista<String> arista = ady.proximo();
				l = arista.verticeDestino().posicion();
				if (!C[l]) {// (8) si (w no está conocido)
					Vertice<String> w = arista.verticeDestino();
					if (D[l] > (D[v.posicion()] + arista.peso())) {// (9) si (Dw > Du + c(u,w)) {
						D[l] = (D[v.posicion()] + arista.peso());// (10) Dw = Du + c(u,w);
						P[l] = v.posicion();// (11) Pw = u;
					}
					if (arista.verticeDestino().dato().equals(ciudad2)) {
						llegue = true;
						k = j;
						break;
					}
				}
			}
		}
		if (llegue) {
			int pos = k;
			while (D[pos] != 0) {
				lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
				pos = P[pos];
			}
			lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
		}
	}

	private void caminoMinNoPesado(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> lis, String ciudad2) {
		ListaGenerica<Arista<String>> ady = null;
		Integer[] D = new Integer[mapaCiudades.listaDeVertices().tamanio()];
		Integer[] P = new Integer[mapaCiudades.listaDeVertices().tamanio()];
		int j, k = i;
		boolean llegue = false;
		for (j = 0; j < grafo.listaDeVertices().tamanio(); j++) {
			D[j] = null;
			P[j] = 0;
		}
		Cola<Vertice<String>> q = new Cola<Vertice<String>>();
		q.encolar(grafo.listaDeVertices().elemento(i));
		D[i] = 0;
		while (!q.esVacia() && !llegue) {
			Vertice<String> v = q.desencolar();
			ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			while (!ady.fin()) {
				Arista<String> arista = ady.proximo();
				j = arista.verticeDestino().posicion();
				if (D[j] == null) {
					Vertice<String> w = arista.verticeDestino();
					D[j] = D[v.posicion()] + 1;
					P[j] = v.posicion();
					if (arista.verticeDestino().dato().equals(ciudad2)) {
						llegue = true;
						k = j;
						break;
					}
					q.encolar(w);
				}
			}
		}
		if (llegue) {
			int pos = k;
			while (D[pos] != 0) {
				lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
				pos = P[pos];
			}
			lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
		}

	}

	/*
	 * El método caminoSinCargarCombustible(String ciudad1, String ciudad2, int
	 * tanqueAuto): ListaGenerica<String> // Retorna la lista de ciudades que forman
	 * un camino para llegar de ciudad1 a ciudad2. El auto no debe quedarse sin
	 * combustible y no puede cargar. Si no existe camino retorna la lista vacía.
	 */
	public ListaGenerica<String> caminoSinCargarCombustible(String ciudad1, String ciudad2, int tanqueAuto) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.caminoSinCargarCombustible(i, mapaCiudades, res, ciudad2, tanqueAuto, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}

	private boolean caminoSinCargarCombustible(int i, Grafo<String> grafo, ListaGenerica<String> lis, String ciudad2,
			int tanqueAuto, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				Arista<String> arista = ady.proximo();
				if ((tanqueAuto - arista.peso()) >= 0) {
					int j = arista.verticeDestino().posicion();
					if (!marca[j]) {
						llegue = this.caminoSinCargarCombustible(j, grafo, lis, ciudad2, tanqueAuto - arista.peso(),
								marca);
					}
				}
			}
			if (llegue) {
				return true;
			} else {
				marca[i] = false;
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	/*
	 * El método caminoConMenorCargaDeCombustible (String ciudad1, String ciudad2,
	 * int tanqueAuto): ListaGenerica<String> // Retorna la lista de ciudades que
	 * forman un camino para llegar de ciudad1 a ciudad2 teniendo en cuenta que el
	 * auto debe cargar la menor cantidad de veces. El auto no se debe quedar sin
	 * combustible en medio de una ruta, además puede completar su tanque al llegar
	 * a cualquier ciudad. Si no existe camino retorna la lista vacía.
	 */
	public ListaGenericaEnlazada<String> caminoConMenorCargaDeCombustible(String ciudad1, String ciudad2,
			int tanqueAuto) {
		ListaGenericaEnlazada<String> res = new ListaGenericaEnlazada<String>();
		ListaGenericaEnlazada<String> lis = new ListaGenericaEnlazada<String>();
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		Peso min = new Peso();
		min.minimo();
		int peso = 0;
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			this.caminoConMenorCargaDeCombustible(i, mapaCiudades, res, min, lis, peso, tanqueAuto, tanqueAuto, ciudad2,
					marca);
		}
		return res;
	}

	private void caminoConMenorCargaDeCombustible(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> res,
			Peso min, ListaGenericaEnlazada<String> lis, int peso, int tanqueAuto, int lleno, String ciudad2,
			boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			if (peso < min.peso) {
				res.comenzar();
				while (!res.esVacia()) {
					res.eliminarEn(0);
				}
				lis.comenzar();
				while (!lis.fin()) {
					res.agregarFinal(lis.proximo());
				}
				min.peso = peso;
			}
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			Arista<String> arista;
			ady.comenzar();
			while (!ady.fin()) {
				arista = ady.proximo();
				int j = arista.verticeDestino().posicion();
				if ((tanqueAuto - arista.peso()) >= 0) ((tanqueAuto - arista.peso()) >= 0) {
					if (!marca[j]) {
						this.caminoConMenorCargaDeCombustible(j, grafo, res, min, lis, peso + 1, lleno - arista.peso(),
								lleno, ciudad2, marca);
					}
				} else {
					if (!marca[j]) {
						this.caminoConMenorCargaDeCombustible(j, grafo, res, min, lis, peso, tanqueAuto - arista.peso(),
								lleno, ciudad2, marca);
					}
				}

			}
		}
		lis.eliminarEn(lis.tamanio() - 1);
		marca[i] = false;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-10 18:30:15.810
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-10 18:30:15.812
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2022-06-11 17:42:53.464 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2022-06-11 17:42:57.589
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2022-06-11 17:43:03.015
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-11 17:43:03.015
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@72c704f1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@76f9e000,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-11 17:43:03.015
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7612116b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1c05097c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-06-11 17:43:07.802
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-06-11 20:02:43.292 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-06-11 20:02:48.940
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-11 20:02:48.940
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7e76a66f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@72237be8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-11 20:02:48.940
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5c5f12e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@23f8036d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-06-11 20:02:51.828
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2022-06-11 23:46:07.543
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package prog3.grafos.utiles;

import prog3.grafos.Arista;
import prog3.grafos.Grafo;
import prog3.grafos.Vertice;
import prog3.listagenerica.ListaGenerica;
import prog3.listagenerica.ListaGenericaEnlazada;
import prog3.util.Cola;

public class Delta {

	/*
	 * maxIslasDistintas(Grafo<String> grafo) : int // Retorna el número máximo de
	 * islas distintas que se pueden recorrer en el grafo comprando un único boleto.
	 */

	public int maxIslasDistintas(Grafo<String> grafo) {
		ListaGenerica<Vertice<String>> vert = grafo.listaDeVertices();
		boolean[] marca = new boolean[vert.tamanio()];
		int max = Integer.MIN_VALUE;
		boolean llegue = false;
		int i = 0;
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals("Muelle Principal")) {
				i = dest.posicion();
				llegue = true;
			}
		}
		ListaGenerica<Arista<String>> aux = grafo.listaDeAdyacentes(grafo.vertice(i));
		ListaGenerica<Arista<String>> ady = new ListaGenericaEnlazada<>();
		aux.comenzar();
		while (!aux.fin()) {
			ady.agregarFinal(aux.proximo());
		}
		while (!ady.fin()) {
			for(int k=0; k<vert.tamanio(); k++) {
				marca[k] = false;
			}
			Arista<String> arista = ady.proximo();
			int j = arista.verticeDestino().posicion();
			int result = distanciaMax(j, grafo, marca);
			max = Math.max(max, result);
			result = result;
		}
		return max;
	}

	private int distanciaMax(int i, Grafo<String> grafo,, boolean[] marca) {
		private void caminoMasCorto(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> res, Peso min,
				ListaGenericaEnlazada<String> lis, int peso, String ciudad2, boolean[] marca) {
			marca[i] = true;
			Vertice<String> v = grafo.listaDeVertices().elemento(i);
			lis.agregarFinal(v.dato());
			if (v.dato().equals(ciudad2)) {
				if (peso < min.getPeso()) {
					res.comenzar();
					while (!res.esVacia()) {
						res.eliminarEn(0);
					}
					lis.comenzar();
					while (!lis.fin()) {
						res.agregarFinal(lis.proximo());
					}
					min.setPeso(peso);
				}
			} else {
				ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
				Arista<String> arista;
				ady.comenzar();
				while (!ady.fin()) {
					arista = ady.proximo();
					int j = arista.verticeDestino().posicion();
					if (!marca[j]) {
						this.caminoMasCorto(j, grafo, res, min, lis, peso + arista.peso(), ciudad2, marca);
					}
				}
			}
			lis.eliminarEn(lis.tamanio() - 1);
			marca[i] = false;
		}

	/*
	 * caminoMasCorto(Grafo<String> grafo, String islaO, String islaD) : RutaMinima
	 * // Retorna un objeto de la clase RutaMinima, el cual contiene el camino más
	 * corto entre islaO e islaD y si se puede realizar con un único boleto o es
	 * necesario comprar un nuevo boleto para completar el recorrido.
	 */

	public RutaMinima caminoMasCorto(Grafo<String> grafo, String islaO, String islaD) {
		RutaMinima res = new RutaMinima();
		ListaGenericaEnlazada<String> lis = new ListaGenericaEnlazada<String>();
		ListaGenerica<Vertice<String>> vert = grafo.listaDeVertices();
		boolean[] marca = new boolean[vert.tamanio()];
		Peso min = new Peso();
		min.minimo();
		int peso = 0;
		boolean llegue = false;
		int i = -1;
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(islaO)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			this.caminoMasCorto(i, grafo, res, min, lis, peso, true, islaD, marca);
		}
		return res;
	}

	private void caminoMasCorto(int i, Grafo<String> grafo, RutaMinima res, Peso min, ListaGenericaEnlazada<String> lis,
			int peso, boolean unico, String islaD, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(islaD)) {
			if (peso < min.getPeso()) {
				ListaGenerica<String> nueva = new ListaGenericaEnlazada<String>();
				lis.comenzar();
				while (!lis.fin()) {
					nueva.agregarFinal(lis.proximo());
				}
				res.setCamino(nueva);
				res.setUnico(unico);
				min.setPeso(peso);
			}
		} else {
			if (v.dato().equals("Muelle Principal")&&(lis.incluye("Muelle Principal"))) {
				unico = false;
			}
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			Arista<String> arista;
			ady.comenzar();
			while (!ady.fin()) {
				arista = ady.proximo();
				int j = arista.verticeDestino().posicion();
				if (!marca[j]) {
					this.caminoMasCorto(j, grafo, res, min, lis, peso + arista.peso(), unico, islaD, marca);
				}
			}
		}
		lis.eliminarEn(lis.tamanio() - 1);
		marca[i] = false;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-06-11 23:46:07.545
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-06-11 23:46:07.546
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-11 23:46:07.659
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package prog3.grafos.utiles;

import prog3.grafos.Arista;
import prog3.grafos.Grafo;
import prog3.grafos.Vertice;
import prog3.listagenerica.ListaGenerica;
import prog3.listagenerica.ListaGenericaEnlazada;
import prog3.util.Cola;

public class Delta {

	/*
	 * maxIslasDistintas(Grafo<String> grafo) : int // Retorna el número máximo de
	 * islas distintas que se pueden recorrer en el grafo comprando un único boleto.
	 */

	public int maxIslasDistintas(Grafo<String> grafo) {
		ListaGenerica<Vertice<String>> vert = grafo.listaDeVertices();
		boolean[] marca = new boolean[vert.tamanio()];
		int max = Integer.MIN_VALUE;
		boolean llegue = false;
		int i = 0;
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals("Muelle Principal")) {
				i = dest.posicion();
				llegue = true;
			}
		}
		ListaGenerica<Arista<String>> aux = grafo.listaDeAdyacentes(grafo.vertice(i));
		ListaGenerica<Arista<String>> ady = new ListaGenericaEnlazada<>();
		aux.comenzar();
		while (!aux.fin()) {
			ady.agregarFinal(aux.proximo());
		}
		while (!ady.fin()) {
			for(int k=0; k<vert.tamanio(); k++) {
				marca[k] = false;
			}
			Arista<String> arista = ady.proximo();
			int j = arista.verticeDestino().posicion();
			int result = distanciaMax(j, grafo, marca);
			max = Math.max(max, result);
			result = result;
		}
		return max;
	}

	private int distanciaMax(int i, Grafo<String> grafo, , boolean[] marca) {
		private void caminoMasCorto(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> res, Peso min,
				ListaGenericaEnlazada<String> lis, int peso, String ciudad2, boolean[] marca) {
			marca[i] = true;
			Vertice<String> v = grafo.listaDeVertices().elemento(i);
			lis.agregarFinal(v.dato());
			if (v.dato().equals(ciudad2)) {
				if (peso < min.getPeso()) {
					res.comenzar();
					while (!res.esVacia()) {
						res.eliminarEn(0);
					}
					lis.comenzar();
					while (!lis.fin()) {
						res.agregarFinal(lis.proximo());
					}
					min.setPeso(peso);
				}
			} else {
				ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
				Arista<String> arista;
				ady.comenzar();
				while (!ady.fin()) {
					arista = ady.proximo();
					int j = arista.verticeDestino().posicion();
					if (!marca[j]) {
						this.caminoMasCorto(j, grafo, res, min, lis, peso + arista.peso(), ciudad2, marca);
					}
				}
			}
			lis.eliminarEn(lis.tamanio() - 1);
			marca[i] = false;
		}

	/*
	 * caminoMasCorto(Grafo<String> grafo, String islaO, String islaD) : RutaMinima
	 * // Retorna un objeto de la clase RutaMinima, el cual contiene el camino más
	 * corto entre islaO e islaD y si se puede realizar con un único boleto o es
	 * necesario comprar un nuevo boleto para completar el recorrido.
	 */

	public RutaMinima caminoMasCorto(Grafo<String> grafo, String islaO, String islaD) {
		RutaMinima res = new RutaMinima();
		ListaGenericaEnlazada<String> lis = new ListaGenericaEnlazada<String>();
		ListaGenerica<Vertice<String>> vert = grafo.listaDeVertices();
		boolean[] marca = new boolean[vert.tamanio()];
		Peso min = new Peso();
		min.minimo();
		int peso = 0;
		boolean llegue = false;
		int i = -1;
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(islaO)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			this.caminoMasCorto(i, grafo, res, min, lis, peso, true, islaD, marca);
		}
		return res;
	}

	private void caminoMasCorto(int i, Grafo<String> grafo, RutaMinima res, Peso min, ListaGenericaEnlazada<String> lis,
			int peso, boolean unico, String islaD, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(islaD)) {
			if (peso < min.getPeso()) {
				ListaGenerica<String> nueva = new ListaGenericaEnlazada<String>();
				lis.comenzar();
				while (!lis.fin()) {
					nueva.agregarFinal(lis.proximo());
				}
				res.setCamino(nueva);
				res.setUnico(unico);
				min.setPeso(peso);
			}
		} else {
			if (v.dato().equals("Muelle Principal")&&(lis.incluye("Muelle Principal"))) {
				unico = false;
			}
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			Arista<String> arista;
			ady.comenzar();
			while (!ady.fin()) {
				arista = ady.proximo();
				int j = arista.verticeDestino().posicion();
				if (!marca[j]) {
					this.caminoMasCorto(j, grafo, res, min, lis, peso + arista.peso(), unico, islaD, marca);
				}
			}
		}
		lis.eliminarEn(lis.tamanio() - 1);
		marca[i] = false;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-06-11 23:46:07.660
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-06-11 23:46:07.660
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-11 23:46:10.052
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package prog3.grafos.utiles;

import prog3.grafos.Arista;
import prog3.grafos.Grafo;
import prog3.grafos.Vertice;
import prog3.listagenerica.ListaGenerica;
import prog3.listagenerica.ListaGenericaEnlazada;
import prog3.util.Cola;

public class Delta {

	/*
	 * maxIslasDistintas(Grafo<String> grafo) : int // Retorna el número máximo de
	 * islas distintas que se pueden recorrer en el grafo comprando un único boleto.
	 */

	public int maxIslasDistintas(Grafo<String> grafo) {
		ListaGenerica<Vertice<String>> vert = grafo.listaDeVertices();
		boolean[] marca = new boolean[vert.tamanio()];
		int max = Integer.MIN_VALUE;
		boolean llegue = false;
		int i = 0;
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals("Muelle Principal")) {
				i = dest.posicion();
				llegue = true;
			}
		}
		ListaGenerica<Arista<String>> aux = grafo.listaDeAdyacentes(grafo.vertice(i));
		ListaGenerica<Arista<String>> ady = new ListaGenericaEnlazada<>();
		aux.comenzar();
		while (!aux.fin()) {
			ady.agregarFinal(aux.proximo());
		}
		while (!ady.fin()) {
			for(int k=0; k<vert.tamanio(); k++) {
				marca[k] = false;
			}
			Arista<String> arista = ady.proximo();
			int j = arista.verticeDestino().posicion();
			int result = distanciaMax(j, grafo, marca);
			max = Math.max(max, result);
			result = result;
		}
		return max;
	}

	private int distanciaMax(int i, Grafo<String> grafo, Peso , boolean[] marca) {
		private void caminoMasCorto(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> res, Peso min,
				ListaGenericaEnlazada<String> lis, int peso, String ciudad2, boolean[] marca) {
			marca[i] = true;
			Vertice<String> v = grafo.listaDeVertices().elemento(i);
			lis.agregarFinal(v.dato());
			if (v.dato().equals(ciudad2)) {
				if (peso < min.getPeso()) {
					res.comenzar();
					while (!res.esVacia()) {
						res.eliminarEn(0);
					}
					lis.comenzar();
					while (!lis.fin()) {
						res.agregarFinal(lis.proximo());
					}
					min.setPeso(peso);
				}
			} else {
				ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
				Arista<String> arista;
				ady.comenzar();
				while (!ady.fin()) {
					arista = ady.proximo();
					int j = arista.verticeDestino().posicion();
					if (!marca[j]) {
						this.caminoMasCorto(j, grafo, res, min, lis, peso + arista.peso(), ciudad2, marca);
					}
				}
			}
			lis.eliminarEn(lis.tamanio() - 1);
			marca[i] = false;
		}

	/*
	 * caminoMasCorto(Grafo<String> grafo, String islaO, String islaD) : RutaMinima
	 * // Retorna un objeto de la clase RutaMinima, el cual contiene el camino más
	 * corto entre islaO e islaD y si se puede realizar con un único boleto o es
	 * necesario comprar un nuevo boleto para completar el recorrido.
	 */

	public RutaMinima caminoMasCorto(Grafo<String> grafo, String islaO, String islaD) {
		RutaMinima res = new RutaMinima();
		ListaGenericaEnlazada<String> lis = new ListaGenericaEnlazada<String>();
		ListaGenerica<Vertice<String>> vert = grafo.listaDeVertices();
		boolean[] marca = new boolean[vert.tamanio()];
		Peso min = new Peso();
		min.minimo();
		int peso = 0;
		boolean llegue = false;
		int i = -1;
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(islaO)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			this.caminoMasCorto(i, grafo, res, min, lis, peso, true, islaD, marca);
		}
		return res;
	}

	private void caminoMasCorto(int i, Grafo<String> grafo, RutaMinima res, Peso min, ListaGenericaEnlazada<String> lis,
			int peso, boolean unico, String islaD, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(islaD)) {
			if (peso < min.getPeso()) {
				ListaGenerica<String> nueva = new ListaGenericaEnlazada<String>();
				lis.comenzar();
				while (!lis.fin()) {
					nueva.agregarFinal(lis.proximo());
				}
				res.setCamino(nueva);
				res.setUnico(unico);
				min.setPeso(peso);
			}
		} else {
			if (v.dato().equals("Muelle Principal")&&(lis.incluye("Muelle Principal"))) {
				unico = false;
			}
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			Arista<String> arista;
			ady.comenzar();
			while (!ady.fin()) {
				arista = ady.proximo();
				int j = arista.verticeDestino().posicion();
				if (!marca[j]) {
					this.caminoMasCorto(j, grafo, res, min, lis, peso + arista.peso(), unico, islaD, marca);
				}
			}
		}
		lis.eliminarEn(lis.tamanio() - 1);
		marca[i] = false;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-06-11 23:46:10.053
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-06-11 23:46:10.053
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-11 23:46:13.892
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package prog3.grafos.utiles;

import prog3.grafos.Arista;
import prog3.grafos.Grafo;
import prog3.grafos.Vertice;
import prog3.listagenerica.ListaGenerica;
import prog3.listagenerica.ListaGenericaEnlazada;
import prog3.util.Cola;

public class Delta {

	/*
	 * maxIslasDistintas(Grafo<String> grafo) : int // Retorna el número máximo de
	 * islas distintas que se pueden recorrer en el grafo comprando un único boleto.
	 */

	public int maxIslasDistintas(Grafo<String> grafo) {
		ListaGenerica<Vertice<String>> vert = grafo.listaDeVertices();
		boolean[] marca = new boolean[vert.tamanio()];
		int max = Integer.MIN_VALUE;
		boolean llegue = false;
		int i = 0;
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals("Muelle Principal")) {
				i = dest.posicion();
				llegue = true;
			}
		}
		ListaGenerica<Arista<String>> aux = grafo.listaDeAdyacentes(grafo.vertice(i));
		ListaGenerica<Arista<String>> ady = new ListaGenericaEnlazada<>();
		aux.comenzar();
		while (!aux.fin()) {
			ady.agregarFinal(aux.proximo());
		}
		while (!ady.fin()) {
			for(int k=0; k<vert.tamanio(); k++) {
				marca[k] = false;
			}
			Arista<String> arista = ady.proximo();
			int j = arista.verticeDestino().posicion();
			int result = distanciaMax(j, grafo, marca);
			max = Math.max(max, result);
			result = result;
		}
		return max;
	}

	private int distanciaMax(int i, Grafo<String> grafo, Peso max,, boolean[] marca) {
		private void caminoMasCorto(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> res, Peso min,
				ListaGenericaEnlazada<String> lis, int peso, String ciudad2, boolean[] marca) {
			marca[i] = true;
			Vertice<String> v = grafo.listaDeVertices().elemento(i);
			lis.agregarFinal(v.dato());
			if (v.dato().equals(ciudad2)) {
				if (peso < min.getPeso()) {
					res.comenzar();
					while (!res.esVacia()) {
						res.eliminarEn(0);
					}
					lis.comenzar();
					while (!lis.fin()) {
						res.agregarFinal(lis.proximo());
					}
					min.setPeso(peso);
				}
			} else {
				ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
				Arista<String> arista;
				ady.comenzar();
				while (!ady.fin()) {
					arista = ady.proximo();
					int j = arista.verticeDestino().posicion();
					if (!marca[j]) {
						this.caminoMasCorto(j, grafo, res, min, lis, peso + arista.peso(), ciudad2, marca);
					}
				}
			}
			lis.eliminarEn(lis.tamanio() - 1);
			marca[i] = false;
		}

	/*
	 * caminoMasCorto(Grafo<String> grafo, String islaO, String islaD) : RutaMinima
	 * // Retorna un objeto de la clase RutaMinima, el cual contiene el camino más
	 * corto entre islaO e islaD y si se puede realizar con un único boleto o es
	 * necesario comprar un nuevo boleto para completar el recorrido.
	 */

	public RutaMinima caminoMasCorto(Grafo<String> grafo, String islaO, String islaD) {
		RutaMinima res = new RutaMinima();
		ListaGenericaEnlazada<String> lis = new ListaGenericaEnlazada<String>();
		ListaGenerica<Vertice<String>> vert = grafo.listaDeVertices();
		boolean[] marca = new boolean[vert.tamanio()];
		Peso min = new Peso();
		min.minimo();
		int peso = 0;
		boolean llegue = false;
		int i = -1;
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(islaO)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			this.caminoMasCorto(i, grafo, res, min, lis, peso, true, islaD, marca);
		}
		return res;
	}

	private void caminoMasCorto(int i, Grafo<String> grafo, RutaMinima res, Peso min, ListaGenericaEnlazada<String> lis,
			int peso, boolean unico, String islaD, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(islaD)) {
			if (peso < min.getPeso()) {
				ListaGenerica<String> nueva = new ListaGenericaEnlazada<String>();
				lis.comenzar();
				while (!lis.fin()) {
					nueva.agregarFinal(lis.proximo());
				}
				res.setCamino(nueva);
				res.setUnico(unico);
				min.setPeso(peso);
			}
		} else {
			if (v.dato().equals("Muelle Principal")&&(lis.incluye("Muelle Principal"))) {
				unico = false;
			}
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			Arista<String> arista;
			ady.comenzar();
			while (!ady.fin()) {
				arista = ady.proximo();
				int j = arista.verticeDestino().posicion();
				if (!marca[j]) {
					this.caminoMasCorto(j, grafo, res, min, lis, peso + arista.peso(), unico, islaD, marca);
				}
			}
		}
		lis.eliminarEn(lis.tamanio() - 1);
		marca[i] = false;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-06-11 23:46:13.893
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-06-11 23:46:13.893
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-11 23:46:14.043
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package prog3.grafos.utiles;

import prog3.grafos.Arista;
import prog3.grafos.Grafo;
import prog3.grafos.Vertice;
import prog3.listagenerica.ListaGenerica;
import prog3.listagenerica.ListaGenericaEnlazada;
import prog3.util.Cola;

public class Delta {

	/*
	 * maxIslasDistintas(Grafo<String> grafo) : int // Retorna el número máximo de
	 * islas distintas que se pueden recorrer en el grafo comprando un único boleto.
	 */

	public int maxIslasDistintas(Grafo<String> grafo) {
		ListaGenerica<Vertice<String>> vert = grafo.listaDeVertices();
		boolean[] marca = new boolean[vert.tamanio()];
		int max = Integer.MIN_VALUE;
		boolean llegue = false;
		int i = 0;
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals("Muelle Principal")) {
				i = dest.posicion();
				llegue = true;
			}
		}
		ListaGenerica<Arista<String>> aux = grafo.listaDeAdyacentes(grafo.vertice(i));
		ListaGenerica<Arista<String>> ady = new ListaGenericaEnlazada<>();
		aux.comenzar();
		while (!aux.fin()) {
			ady.agregarFinal(aux.proximo());
		}
		while (!ady.fin()) {
			for(int k=0; k<vert.tamanio(); k++) {
				marca[k] = false;
			}
			Arista<String> arista = ady.proximo();
			int j = arista.verticeDestino().posicion();
			int result = distanciaMax(j, grafo, marca);
			max = Math.max(max, result);
			result = result;
		}
		return max;
	}

	private int distanciaMax(int i, Grafo<String> grafo, Peso max, , boolean[] marca) {
		private void caminoMasCorto(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> res, Peso min,
				ListaGenericaEnlazada<String> lis, int peso, String ciudad2, boolean[] marca) {
			marca[i] = true;
			Vertice<String> v = grafo.listaDeVertices().elemento(i);
			lis.agregarFinal(v.dato());
			if (v.dato().equals(ciudad2)) {
				if (peso < min.getPeso()) {
					res.comenzar();
					while (!res.esVacia()) {
						res.eliminarEn(0);
					}
					lis.comenzar();
					while (!lis.fin()) {
						res.agregarFinal(lis.proximo());
					}
					min.setPeso(peso);
				}
			} else {
				ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
				Arista<String> arista;
				ady.comenzar();
				while (!ady.fin()) {
					arista = ady.proximo();
					int j = arista.verticeDestino().posicion();
					if (!marca[j]) {
						this.caminoMasCorto(j, grafo, res, min, lis, peso + arista.peso(), ciudad2, marca);
					}
				}
			}
			lis.eliminarEn(lis.tamanio() - 1);
			marca[i] = false;
		}

	/*
	 * caminoMasCorto(Grafo<String> grafo, String islaO, String islaD) : RutaMinima
	 * // Retorna un objeto de la clase RutaMinima, el cual contiene el camino más
	 * corto entre islaO e islaD y si se puede realizar con un único boleto o es
	 * necesario comprar un nuevo boleto para completar el recorrido.
	 */

	public RutaMinima caminoMasCorto(Grafo<String> grafo, String islaO, String islaD) {
		RutaMinima res = new RutaMinima();
		ListaGenericaEnlazada<String> lis = new ListaGenericaEnlazada<String>();
		ListaGenerica<Vertice<String>> vert = grafo.listaDeVertices();
		boolean[] marca = new boolean[vert.tamanio()];
		Peso min = new Peso();
		min.minimo();
		int peso = 0;
		boolean llegue = false;
		int i = -1;
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(islaO)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			this.caminoMasCorto(i, grafo, res, min, lis, peso, true, islaD, marca);
		}
		return res;
	}

	private void caminoMasCorto(int i, Grafo<String> grafo, RutaMinima res, Peso min, ListaGenericaEnlazada<String> lis,
			int peso, boolean unico, String islaD, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(islaD)) {
			if (peso < min.getPeso()) {
				ListaGenerica<String> nueva = new ListaGenericaEnlazada<String>();
				lis.comenzar();
				while (!lis.fin()) {
					nueva.agregarFinal(lis.proximo());
				}
				res.setCamino(nueva);
				res.setUnico(unico);
				min.setPeso(peso);
			}
		} else {
			if (v.dato().equals("Muelle Principal")&&(lis.incluye("Muelle Principal"))) {
				unico = false;
			}
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			Arista<String> arista;
			ady.comenzar();
			while (!ady.fin()) {
				arista = ady.proximo();
				int j = arista.verticeDestino().posicion();
				if (!marca[j]) {
					this.caminoMasCorto(j, grafo, res, min, lis, peso + arista.peso(), unico, islaD, marca);
				}
			}
		}
		lis.eliminarEn(lis.tamanio() - 1);
		marca[i] = false;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-06-11 23:46:14.044
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-06-11 23:46:14.044
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-11 23:46:16.356
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package prog3.grafos.utiles;

import prog3.grafos.Arista;
import prog3.grafos.Grafo;
import prog3.grafos.Vertice;
import prog3.listagenerica.ListaGenerica;
import prog3.listagenerica.ListaGenericaEnlazada;
import prog3.util.Cola;

public class Delta {

	/*
	 * maxIslasDistintas(Grafo<String> grafo) : int // Retorna el número máximo de
	 * islas distintas que se pueden recorrer en el grafo comprando un único boleto.
	 */

	public int maxIslasDistintas(Grafo<String> grafo) {
		ListaGenerica<Vertice<String>> vert = grafo.listaDeVertices();
		boolean[] marca = new boolean[vert.tamanio()];
		int max = Integer.MIN_VALUE;
		boolean llegue = false;
		int i = 0;
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals("Muelle Principal")) {
				i = dest.posicion();
				llegue = true;
			}
		}
		ListaGenerica<Arista<String>> aux = grafo.listaDeAdyacentes(grafo.vertice(i));
		ListaGenerica<Arista<String>> ady = new ListaGenericaEnlazada<>();
		aux.comenzar();
		while (!aux.fin()) {
			ady.agregarFinal(aux.proximo());
		}
		while (!ady.fin()) {
			for(int k=0; k<vert.tamanio(); k++) {
				marca[k] = false;
			}
			Arista<String> arista = ady.proximo();
			int j = arista.verticeDestino().posicion();
			int result = distanciaMax(j, grafo, marca);
			max = Math.max(max, result);
			result = result;
		}
		return max;
	}

	private int distanciaMax(int i, Grafo<String> grafo, Peso max, Lis, boolean[] marca) {
		private void caminoMasCorto(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> res, Peso min,
				ListaGenericaEnlazada<String> lis, int peso, String ciudad2, boolean[] marca) {
			marca[i] = true;
			Vertice<String> v = grafo.listaDeVertices().elemento(i);
			lis.agregarFinal(v.dato());
			if (v.dato().equals(ciudad2)) {
				if (peso < min.getPeso()) {
					res.comenzar();
					while (!res.esVacia()) {
						res.eliminarEn(0);
					}
					lis.comenzar();
					while (!lis.fin()) {
						res.agregarFinal(lis.proximo());
					}
					min.setPeso(peso);
				}
			} else {
				ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
				Arista<String> arista;
				ady.comenzar();
				while (!ady.fin()) {
					arista = ady.proximo();
					int j = arista.verticeDestino().posicion();
					if (!marca[j]) {
						this.caminoMasCorto(j, grafo, res, min, lis, peso + arista.peso(), ciudad2, marca);
					}
				}
			}
			lis.eliminarEn(lis.tamanio() - 1);
			marca[i] = false;
		}

	/*
	 * caminoMasCorto(Grafo<String> grafo, String islaO, String islaD) : RutaMinima
	 * // Retorna un objeto de la clase RutaMinima, el cual contiene el camino más
	 * corto entre islaO e islaD y si se puede realizar con un único boleto o es
	 * necesario comprar un nuevo boleto para completar el recorrido.
	 */

	public RutaMinima caminoMasCorto(Grafo<String> grafo, String islaO, String islaD) {
		RutaMinima res = new RutaMinima();
		ListaGenericaEnlazada<String> lis = new ListaGenericaEnlazada<String>();
		ListaGenerica<Vertice<String>> vert = grafo.listaDeVertices();
		boolean[] marca = new boolean[vert.tamanio()];
		Peso min = new Peso();
		min.minimo();
		int peso = 0;
		boolean llegue = false;
		int i = -1;
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(islaO)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			this.caminoMasCorto(i, grafo, res, min, lis, peso, true, islaD, marca);
		}
		return res;
	}

	private void caminoMasCorto(int i, Grafo<String> grafo, RutaMinima res, Peso min, ListaGenericaEnlazada<String> lis,
			int peso, boolean unico, String islaD, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(islaD)) {
			if (peso < min.getPeso()) {
				ListaGenerica<String> nueva = new ListaGenericaEnlazada<String>();
				lis.comenzar();
				while (!lis.fin()) {
					nueva.agregarFinal(lis.proximo());
				}
				res.setCamino(nueva);
				res.setUnico(unico);
				min.setPeso(peso);
			}
		} else {
			if (v.dato().equals("Muelle Principal")&&(lis.incluye("Muelle Principal"))) {
				unico = false;
			}
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			Arista<String> arista;
			ady.comenzar();
			while (!ady.fin()) {
				arista = ady.proximo();
				int j = arista.verticeDestino().posicion();
				if (!marca[j]) {
					this.caminoMasCorto(j, grafo, res, min, lis, peso + arista.peso(), unico, islaD, marca);
				}
			}
		}
		lis.eliminarEn(lis.tamanio() - 1);
		marca[i] = false;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-06-11 23:46:16.357
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-06-11 23:46:16.357
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-11 23:46:17.009
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package prog3.grafos.utiles;

import prog3.grafos.Arista;
import prog3.grafos.Grafo;
import prog3.grafos.Vertice;
import prog3.listagenerica.ListaGenerica;
import prog3.listagenerica.ListaGenericaEnlazada;
import prog3.util.Cola;

public class Delta {

	/*
	 * maxIslasDistintas(Grafo<String> grafo) : int // Retorna el número máximo de
	 * islas distintas que se pueden recorrer en el grafo comprando un único boleto.
	 */

	public int maxIslasDistintas(Grafo<String> grafo) {
		ListaGenerica<Vertice<String>> vert = grafo.listaDeVertices();
		boolean[] marca = new boolean[vert.tamanio()];
		int max = Integer.MIN_VALUE;
		boolean llegue = false;
		int i = 0;
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals("Muelle Principal")) {
				i = dest.posicion();
				llegue = true;
			}
		}
		ListaGenerica<Arista<String>> aux = grafo.listaDeAdyacentes(grafo.vertice(i));
		ListaGenerica<Arista<String>> ady = new ListaGenericaEnlazada<>();
		aux.comenzar();
		while (!aux.fin()) {
			ady.agregarFinal(aux.proximo());
		}
		while (!ady.fin()) {
			for(int k=0; k<vert.tamanio(); k++) {
				marca[k] = false;
			}
			Arista<String> arista = ady.proximo();
			int j = arista.verticeDestino().posicion();
			int result = distanciaMax(j, grafo, marca);
			max = Math.max(max, result);
			result = result;
		}
		return max;
	}

	private int distanciaMax(int i, Grafo<String> grafo, Peso max, Lista, boolean[] marca) {
		private void caminoMasCorto(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> res, Peso min,
				ListaGenericaEnlazada<String> lis, int peso, String ciudad2, boolean[] marca) {
			marca[i] = true;
			Vertice<String> v = grafo.listaDeVertices().elemento(i);
			lis.agregarFinal(v.dato());
			if (v.dato().equals(ciudad2)) {
				if (peso < min.getPeso()) {
					res.comenzar();
					while (!res.esVacia()) {
						res.eliminarEn(0);
					}
					lis.comenzar();
					while (!lis.fin()) {
						res.agregarFinal(lis.proximo());
					}
					min.setPeso(peso);
				}
			} else {
				ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
				Arista<String> arista;
				ady.comenzar();
				while (!ady.fin()) {
					arista = ady.proximo();
					int j = arista.verticeDestino().posicion();
					if (!marca[j]) {
						this.caminoMasCorto(j, grafo, res, min, lis, peso + arista.peso(), ciudad2, marca);
					}
				}
			}
			lis.eliminarEn(lis.tamanio() - 1);
			marca[i] = false;
		}

	/*
	 * caminoMasCorto(Grafo<String> grafo, String islaO, String islaD) : RutaMinima
	 * // Retorna un objeto de la clase RutaMinima, el cual contiene el camino más
	 * corto entre islaO e islaD y si se puede realizar con un único boleto o es
	 * necesario comprar un nuevo boleto para completar el recorrido.
	 */

	public RutaMinima caminoMasCorto(Grafo<String> grafo, String islaO, String islaD) {
		RutaMinima res = new RutaMinima();
		ListaGenericaEnlazada<String> lis = new ListaGenericaEnlazada<String>();
		ListaGenerica<Vertice<String>> vert = grafo.listaDeVertices();
		boolean[] marca = new boolean[vert.tamanio()];
		Peso min = new Peso();
		min.minimo();
		int peso = 0;
		boolean llegue = false;
		int i = -1;
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(islaO)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			this.caminoMasCorto(i, grafo, res, min, lis, peso, true, islaD, marca);
		}
		return res;
	}

	private void caminoMasCorto(int i, Grafo<String> grafo, RutaMinima res, Peso min, ListaGenericaEnlazada<String> lis,
			int peso, boolean unico, String islaD, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(islaD)) {
			if (peso < min.getPeso()) {
				ListaGenerica<String> nueva = new ListaGenericaEnlazada<String>();
				lis.comenzar();
				while (!lis.fin()) {
					nueva.agregarFinal(lis.proximo());
				}
				res.setCamino(nueva);
				res.setUnico(unico);
				min.setPeso(peso);
			}
		} else {
			if (v.dato().equals("Muelle Principal")&&(lis.incluye("Muelle Principal"))) {
				unico = false;
			}
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			Arista<String> arista;
			ady.comenzar();
			while (!ady.fin()) {
				arista = ady.proximo();
				int j = arista.verticeDestino().posicion();
				if (!marca[j]) {
					this.caminoMasCorto(j, grafo, res, min, lis, peso + arista.peso(), unico, islaD, marca);
				}
			}
		}
		lis.eliminarEn(lis.tamanio() - 1);
		marca[i] = false;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-06-11 23:46:17.009
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-06-11 23:46:17.009
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-11 23:46:21.794
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package prog3.grafos.utiles;

import prog3.grafos.Arista;
import prog3.grafos.Grafo;
import prog3.grafos.Vertice;
import prog3.listagenerica.ListaGenerica;
import prog3.listagenerica.ListaGenericaEnlazada;
import prog3.util.Cola;

public class Delta {

	/*
	 * maxIslasDistintas(Grafo<String> grafo) : int // Retorna el número máximo de
	 * islas distintas que se pueden recorrer en el grafo comprando un único boleto.
	 */

	public int maxIslasDistintas(Grafo<String> grafo) {
		ListaGenerica<Vertice<String>> vert = grafo.listaDeVertices();
		boolean[] marca = new boolean[vert.tamanio()];
		int max = Integer.MIN_VALUE;
		boolean llegue = false;
		int i = 0;
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals("Muelle Principal")) {
				i = dest.posicion();
				llegue = true;
			}
		}
		ListaGenerica<Arista<String>> aux = grafo.listaDeAdyacentes(grafo.vertice(i));
		ListaGenerica<Arista<String>> ady = new ListaGenericaEnlazada<>();
		aux.comenzar();
		while (!aux.fin()) {
			ady.agregarFinal(aux.proximo());
		}
		while (!ady.fin()) {
			for(int k=0; k<vert.tamanio(); k++) {
				marca[k] = false;
			}
			Arista<String> arista = ady.proximo();
			int j = arista.verticeDestino().posicion();
			int result = distanciaMax(j, grafo, marca);
			max = Math.max(max, result);
			result = result;
		}
		return max;
	}

	private int distanciaMax(int i, Grafo<String> grafo, Peso max, Listage, boolean[] marca) {
		private void caminoMasCorto(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> res, Peso min,
				ListaGenericaEnlazada<String> lis, int peso, String ciudad2, boolean[] marca) {
			marca[i] = true;
			Vertice<String> v = grafo.listaDeVertices().elemento(i);
			lis.agregarFinal(v.dato());
			if (v.dato().equals(ciudad2)) {
				if (peso < min.getPeso()) {
					res.comenzar();
					while (!res.esVacia()) {
						res.eliminarEn(0);
					}
					lis.comenzar();
					while (!lis.fin()) {
						res.agregarFinal(lis.proximo());
					}
					min.setPeso(peso);
				}
			} else {
				ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
				Arista<String> arista;
				ady.comenzar();
				while (!ady.fin()) {
					arista = ady.proximo();
					int j = arista.verticeDestino().posicion();
					if (!marca[j]) {
						this.caminoMasCorto(j, grafo, res, min, lis, peso + arista.peso(), ciudad2, marca);
					}
				}
			}
			lis.eliminarEn(lis.tamanio() - 1);
			marca[i] = false;
		}

	/*
	 * caminoMasCorto(Grafo<String> grafo, String islaO, String islaD) : RutaMinima
	 * // Retorna un objeto de la clase RutaMinima, el cual contiene el camino más
	 * corto entre islaO e islaD y si se puede realizar con un único boleto o es
	 * necesario comprar un nuevo boleto para completar el recorrido.
	 */

	public RutaMinima caminoMasCorto(Grafo<String> grafo, String islaO, String islaD) {
		RutaMinima res = new RutaMinima();
		ListaGenericaEnlazada<String> lis = new ListaGenericaEnlazada<String>();
		ListaGenerica<Vertice<String>> vert = grafo.listaDeVertices();
		boolean[] marca = new boolean[vert.tamanio()];
		Peso min = new Peso();
		min.minimo();
		int peso = 0;
		boolean llegue = false;
		int i = -1;
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(islaO)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			this.caminoMasCorto(i, grafo, res, min, lis, peso, true, islaD, marca);
		}
		return res;
	}

	private void caminoMasCorto(int i, Grafo<String> grafo, RutaMinima res, Peso min, ListaGenericaEnlazada<String> lis,
			int peso, boolean unico, String islaD, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(islaD)) {
			if (peso < min.getPeso()) {
				ListaGenerica<String> nueva = new ListaGenericaEnlazada<String>();
				lis.comenzar();
				while (!lis.fin()) {
					nueva.agregarFinal(lis.proximo());
				}
				res.setCamino(nueva);
				res.setUnico(unico);
				min.setPeso(peso);
			}
		} else {
			if (v.dato().equals("Muelle Principal")&&(lis.incluye("Muelle Principal"))) {
				unico = false;
			}
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			Arista<String> arista;
			ady.comenzar();
			while (!ady.fin()) {
				arista = ady.proximo();
				int j = arista.verticeDestino().posicion();
				if (!marca[j]) {
					this.caminoMasCorto(j, grafo, res, min, lis, peso + arista.peso(), unico, islaD, marca);
				}
			}
		}
		lis.eliminarEn(lis.tamanio() - 1);
		marca[i] = false;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-06-11 23:46:21.795
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-06-11 23:46:21.795
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-11 23:46:23.802
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package prog3.grafos.utiles;

import prog3.grafos.Arista;
import prog3.grafos.Grafo;
import prog3.grafos.Vertice;
import prog3.listagenerica.ListaGenerica;
import prog3.listagenerica.ListaGenericaEnlazada;
import prog3.util.Cola;

public class Delta {

	/*
	 * maxIslasDistintas(Grafo<String> grafo) : int // Retorna el número máximo de
	 * islas distintas que se pueden recorrer en el grafo comprando un único boleto.
	 */

	public int maxIslasDistintas(Grafo<String> grafo) {
		ListaGenerica<Vertice<String>> vert = grafo.listaDeVertices();
		boolean[] marca = new boolean[vert.tamanio()];
		int max = Integer.MIN_VALUE;
		boolean llegue = false;
		int i = 0;
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals("Muelle Principal")) {
				i = dest.posicion();
				llegue = true;
			}
		}
		ListaGenerica<Arista<String>> aux = grafo.listaDeAdyacentes(grafo.vertice(i));
		ListaGenerica<Arista<String>> ady = new ListaGenericaEnlazada<>();
		aux.comenzar();
		while (!aux.fin()) {
			ady.agregarFinal(aux.proximo());
		}
		while (!ady.fin()) {
			for(int k=0; k<vert.tamanio(); k++) {
				marca[k] = false;
			}
			Arista<String> arista = ady.proximo();
			int j = arista.verticeDestino().posicion();
			int result = distanciaMax(j, grafo, marca);
			max = Math.max(max, result);
			result = result;
		}
		return max;
	}

	private int distanciaMax(int i, Grafo<String> grafo, Peso max, , boolean[] marca) {
		private void caminoMasCorto(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> res, Peso min,
				ListaGenericaEnlazada<String> lis, int peso, String ciudad2, boolean[] marca) {
			marca[i] = true;
			Vertice<String> v = grafo.listaDeVertices().elemento(i);
			lis.agregarFinal(v.dato());
			if (v.dato().equals(ciudad2)) {
				if (peso < min.getPeso()) {
					res.comenzar();
					while (!res.esVacia()) {
						res.eliminarEn(0);
					}
					lis.comenzar();
					while (!lis.fin()) {
						res.agregarFinal(lis.proximo());
					}
					min.setPeso(peso);
				}
			} else {
				ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
				Arista<String> arista;
				ady.comenzar();
				while (!ady.fin()) {
					arista = ady.proximo();
					int j = arista.verticeDestino().posicion();
					if (!marca[j]) {
						this.caminoMasCorto(j, grafo, res, min, lis, peso + arista.peso(), ciudad2, marca);
					}
				}
			}
			lis.eliminarEn(lis.tamanio() - 1);
			marca[i] = false;
		}

	/*
	 * caminoMasCorto(Grafo<String> grafo, String islaO, String islaD) : RutaMinima
	 * // Retorna un objeto de la clase RutaMinima, el cual contiene el camino más
	 * corto entre islaO e islaD y si se puede realizar con un único boleto o es
	 * necesario comprar un nuevo boleto para completar el recorrido.
	 */

	public RutaMinima caminoMasCorto(Grafo<String> grafo, String islaO, String islaD) {
		RutaMinima res = new RutaMinima();
		ListaGenericaEnlazada<String> lis = new ListaGenericaEnlazada<String>();
		ListaGenerica<Vertice<String>> vert = grafo.listaDeVertices();
		boolean[] marca = new boolean[vert.tamanio()];
		Peso min = new Peso();
		min.minimo();
		int peso = 0;
		boolean llegue = false;
		int i = -1;
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(islaO)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			this.caminoMasCorto(i, grafo, res, min, lis, peso, true, islaD, marca);
		}
		return res;
	}

	private void caminoMasCorto(int i, Grafo<String> grafo, RutaMinima res, Peso min, ListaGenericaEnlazada<String> lis,
			int peso, boolean unico, String islaD, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(islaD)) {
			if (peso < min.getPeso()) {
				ListaGenerica<String> nueva = new ListaGenericaEnlazada<String>();
				lis.comenzar();
				while (!lis.fin()) {
					nueva.agregarFinal(lis.proximo());
				}
				res.setCamino(nueva);
				res.setUnico(unico);
				min.setPeso(peso);
			}
		} else {
			if (v.dato().equals("Muelle Principal")&&(lis.incluye("Muelle Principal"))) {
				unico = false;
			}
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			Arista<String> arista;
			ady.comenzar();
			while (!ady.fin()) {
				arista = ady.proximo();
				int j = arista.verticeDestino().posicion();
				if (!marca[j]) {
					this.caminoMasCorto(j, grafo, res, min, lis, peso + arista.peso(), unico, islaD, marca);
				}
			}
		}
		lis.eliminarEn(lis.tamanio() - 1);
		marca[i] = false;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-06-11 23:46:23.803
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-06-11 23:46:23.803
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-11 23:46:26.778
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package prog3.grafos.utiles;

import prog3.grafos.Arista;
import prog3.grafos.Grafo;
import prog3.grafos.Vertice;
import prog3.listagenerica.ListaGenerica;
import prog3.listagenerica.ListaGenericaEnlazada;
import prog3.util.Cola;

public class Delta {

	/*
	 * maxIslasDistintas(Grafo<String> grafo) : int // Retorna el número máximo de
	 * islas distintas que se pueden recorrer en el grafo comprando un único boleto.
	 */

	public int maxIslasDistintas(Grafo<String> grafo) {
		ListaGenerica<Vertice<String>> vert = grafo.listaDeVertices();
		boolean[] marca = new boolean[vert.tamanio()];
		int max = Integer.MIN_VALUE;
		boolean llegue = false;
		int i = 0;
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals("Muelle Principal")) {
				i = dest.posicion();
				llegue = true;
			}
		}
		ListaGenerica<Arista<String>> aux = grafo.listaDeAdyacentes(grafo.vertice(i));
		ListaGenerica<Arista<String>> ady = new ListaGenericaEnlazada<>();
		aux.comenzar();
		while (!aux.fin()) {
			ady.agregarFinal(aux.proximo());
		}
		while (!ady.fin()) {
			for(int k=0; k<vert.tamanio(); k++) {
				marca[k] = false;
			}
			Arista<String> arista = ady.proximo();
			int j = arista.verticeDestino().posicion();
			int result = distanciaMax(j, grafo, marca);
			max = Math.max(max, result);
			result = result;
		}
		return max;
	}

	private int distanciaMax(int i, Grafo<String> grafo, Peso max, dist, boolean[] marca) {
		private void caminoMasCorto(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> res, Peso min,
				ListaGenericaEnlazada<String> lis, int peso, String ciudad2, boolean[] marca) {
			marca[i] = true;
			Vertice<String> v = grafo.listaDeVertices().elemento(i);
			lis.agregarFinal(v.dato());
			if (v.dato().equals(ciudad2)) {
				if (peso < min.getPeso()) {
					res.comenzar();
					while (!res.esVacia()) {
						res.eliminarEn(0);
					}
					lis.comenzar();
					while (!lis.fin()) {
						res.agregarFinal(lis.proximo());
					}
					min.setPeso(peso);
				}
			} else {
				ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
				Arista<String> arista;
				ady.comenzar();
				while (!ady.fin()) {
					arista = ady.proximo();
					int j = arista.verticeDestino().posicion();
					if (!marca[j]) {
						this.caminoMasCorto(j, grafo, res, min, lis, peso + arista.peso(), ciudad2, marca);
					}
				}
			}
			lis.eliminarEn(lis.tamanio() - 1);
			marca[i] = false;
		}

	/*
	 * caminoMasCorto(Grafo<String> grafo, String islaO, String islaD) : RutaMinima
	 * // Retorna un objeto de la clase RutaMinima, el cual contiene el camino más
	 * corto entre islaO e islaD y si se puede realizar con un único boleto o es
	 * necesario comprar un nuevo boleto para completar el recorrido.
	 */

	public RutaMinima caminoMasCorto(Grafo<String> grafo, String islaO, String islaD) {
		RutaMinima res = new RutaMinima();
		ListaGenericaEnlazada<String> lis = new ListaGenericaEnlazada<String>();
		ListaGenerica<Vertice<String>> vert = grafo.listaDeVertices();
		boolean[] marca = new boolean[vert.tamanio()];
		Peso min = new Peso();
		min.minimo();
		int peso = 0;
		boolean llegue = false;
		int i = -1;
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(islaO)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			this.caminoMasCorto(i, grafo, res, min, lis, peso, true, islaD, marca);
		}
		return res;
	}

	private void caminoMasCorto(int i, Grafo<String> grafo, RutaMinima res, Peso min, ListaGenericaEnlazada<String> lis,
			int peso, boolean unico, String islaD, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(islaD)) {
			if (peso < min.getPeso()) {
				ListaGenerica<String> nueva = new ListaGenericaEnlazada<String>();
				lis.comenzar();
				while (!lis.fin()) {
					nueva.agregarFinal(lis.proximo());
				}
				res.setCamino(nueva);
				res.setUnico(unico);
				min.setPeso(peso);
			}
		} else {
			if (v.dato().equals("Muelle Principal")&&(lis.incluye("Muelle Principal"))) {
				unico = false;
			}
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			Arista<String> arista;
			ady.comenzar();
			while (!ady.fin()) {
				arista = ady.proximo();
				int j = arista.verticeDestino().posicion();
				if (!marca[j]) {
					this.caminoMasCorto(j, grafo, res, min, lis, peso + arista.peso(), unico, islaD, marca);
				}
			}
		}
		lis.eliminarEn(lis.tamanio() - 1);
		marca[i] = false;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-06-11 23:46:26.778
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-06-11 23:46:26.779
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-11 23:46:29.827
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package prog3.grafos.utiles;

import prog3.grafos.Arista;
import prog3.grafos.Grafo;
import prog3.grafos.Vertice;
import prog3.listagenerica.ListaGenerica;
import prog3.listagenerica.ListaGenericaEnlazada;
import prog3.util.Cola;

public class Delta {

	/*
	 * maxIslasDistintas(Grafo<String> grafo) : int // Retorna el número máximo de
	 * islas distintas que se pueden recorrer en el grafo comprando un único boleto.
	 */

	public int maxIslasDistintas(Grafo<String> grafo) {
		ListaGenerica<Vertice<String>> vert = grafo.listaDeVertices();
		boolean[] marca = new boolean[vert.tamanio()];
		int max = Integer.MIN_VALUE;
		boolean llegue = false;
		int i = 0;
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals("Muelle Principal")) {
				i = dest.posicion();
				llegue = true;
			}
		}
		ListaGenerica<Arista<String>> aux = grafo.listaDeAdyacentes(grafo.vertice(i));
		ListaGenerica<Arista<String>> ady = new ListaGenericaEnlazada<>();
		aux.comenzar();
		while (!aux.fin()) {
			ady.agregarFinal(aux.proximo());
		}
		while (!ady.fin()) {
			for(int k=0; k<vert.tamanio(); k++) {
				marca[k] = false;
			}
			Arista<String> arista = ady.proximo();
			int j = arista.verticeDestino().posicion();
			int result = distanciaMax(j, grafo, marca);
			max = Math.max(max, result);
			result = result;
		}
		return max;
	}

	private int distanciaMax(int i, Grafo<String> grafo, Peso max,  dist, boolean[] marca) {
		private void caminoMasCorto(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> res, Peso min,
				ListaGenericaEnlazada<String> lis, int peso, String ciudad2, boolean[] marca) {
			marca[i] = true;
			Vertice<String> v = grafo.listaDeVertices().elemento(i);
			lis.agregarFinal(v.dato());
			if (v.dato().equals(ciudad2)) {
				if (peso < min.getPeso()) {
					res.comenzar();
					while (!res.esVacia()) {
						res.eliminarEn(0);
					}
					lis.comenzar();
					while (!lis.fin()) {
						res.agregarFinal(lis.proximo());
					}
					min.setPeso(peso);
				}
			} else {
				ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
				Arista<String> arista;
				ady.comenzar();
				while (!ady.fin()) {
					arista = ady.proximo();
					int j = arista.verticeDestino().posicion();
					if (!marca[j]) {
						this.caminoMasCorto(j, grafo, res, min, lis, peso + arista.peso(), ciudad2, marca);
					}
				}
			}
			lis.eliminarEn(lis.tamanio() - 1);
			marca[i] = false;
		}

	/*
	 * caminoMasCorto(Grafo<String> grafo, String islaO, String islaD) : RutaMinima
	 * // Retorna un objeto de la clase RutaMinima, el cual contiene el camino más
	 * corto entre islaO e islaD y si se puede realizar con un único boleto o es
	 * necesario comprar un nuevo boleto para completar el recorrido.
	 */

	public RutaMinima caminoMasCorto(Grafo<String> grafo, String islaO, String islaD) {
		RutaMinima res = new RutaMinima();
		ListaGenericaEnlazada<String> lis = new ListaGenericaEnlazada<String>();
		ListaGenerica<Vertice<String>> vert = grafo.listaDeVertices();
		boolean[] marca = new boolean[vert.tamanio()];
		Peso min = new Peso();
		min.minimo();
		int peso = 0;
		boolean llegue = false;
		int i = -1;
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(islaO)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			this.caminoMasCorto(i, grafo, res, min, lis, peso, true, islaD, marca);
		}
		return res;
	}

	private void caminoMasCorto(int i, Grafo<String> grafo, RutaMinima res, Peso min, ListaGenericaEnlazada<String> lis,
			int peso, boolean unico, String islaD, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(islaD)) {
			if (peso < min.getPeso()) {
				ListaGenerica<String> nueva = new ListaGenericaEnlazada<String>();
				lis.comenzar();
				while (!lis.fin()) {
					nueva.agregarFinal(lis.proximo());
				}
				res.setCamino(nueva);
				res.setUnico(unico);
				min.setPeso(peso);
			}
		} else {
			if (v.dato().equals("Muelle Principal")&&(lis.incluye("Muelle Principal"))) {
				unico = false;
			}
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			Arista<String> arista;
			ady.comenzar();
			while (!ady.fin()) {
				arista = ady.proximo();
				int j = arista.verticeDestino().posicion();
				if (!marca[j]) {
					this.caminoMasCorto(j, grafo, res, min, lis, peso + arista.peso(), unico, islaD, marca);
				}
			}
		}
		lis.eliminarEn(lis.tamanio() - 1);
		marca[i] = false;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-06-11 23:46:29.828
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-06-11 23:46:29.828
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
!SESSION 2022-06-12 11:12:03.743 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-06-12 11:14:20.181
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-12 11:14:20.181
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@615c4ea4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@417446d9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-12 11:14:20.181
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@34070bd2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1e7d3d87,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-06-12 11:14:23.771
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2022-06-12 19:40:23.445
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package prog3.grafos.utiles;

import prog3.grafos.*;
import prog3.listagenerica.*;
import prog3.util.*;

public class Mapa {

	Grafo<String> mapaCiudades = new GrafoImplListAdy<String>();

	public Mapa(Grafo<String> mapaCiudades) {
		super();
		this.mapaCiudades = mapaCiudades;
	}

	/*
	 * El método devolverCamino (String ciudad1, String ciudad2):
	 * ListaGenerica<String> // Retorna la lista de ciudades que se deben atravesar
	 * para ir de ciudad1 a ciudad2 en caso que se pueda llegar, si no retorna la
	 * lista vacía. (Sin tener en cuenta el combustible).
	 */
	public ListaGenerica<String> devolverCamino(String ciudad1, String ciudad2) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.devolverCamino(i, mapaCiudades, res, ciudad2, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}

	private boolean devolverCamino(int i, Grafo<String> grafo, ListaGenerica<String> lis, String ciudad2,
			boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.devolverCamino(j, grafo, lis, ciudad2, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	/*
	 * El método devolverCaminoExceptuando (String ciudad1, String ciudad2,
	 * ListaGenerica<String> ciudades): ListaGenerica<String> // Retorna la lista de
	 * ciudades que forman un camino desde ciudad1 a ciudad2, sin pasar por las
	 * ciudades que están contenidas en la lista ciudades pasada por parámetro, si
	 * no existe camino retorna la lista vacía. (Sin tener en cuenta el
	 * combustible).
	 */
	public ListaGenerica<String> devolverCaminoExceptuando(String ciudad1, String ciudad2,
			ListaGenerica<String> ciudades) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.devolverCaminoExceptuando(i, mapaCiudades, res, ciudades, ciudad2, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}

	private boolean devolverCaminoExceptuando(int i, Grafo<String> grafo, ListaGenerica<String> lis,
			ListaGenerica<String> excepto, String ciudad2, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		excepto.comenzar();
		while (!excepto.fin()) {
			if (v.dato().equals(excepto.proximo())) {
				return false;
			}
		}
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.devolverCaminoExceptuando(j, grafo, lis, excepto, ciudad2, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				marca[i] = false;
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	/*
	 * El método caminoMasCorto(String ciudad1, String ciudad2):
	 * ListaGenerica<String> // Retorna la lista de ciudades que forman el camino
	 * más corto para llegar de ciudad1 a ciudad2, si no existe camino retorna la
	 * lista vacía. (Las rutas poseen la distancia). (Sin tener en cuenta el
	 * combustible).
	 */
	public ListaGenericaEnlazada<String> caminoMasCorto(String ciudad1, String ciudad2) {
		ListaGenericaEnlazada<String> res = new ListaGenericaEnlazada<String>();
		ListaGenericaEnlazada<String> lis = new ListaGenericaEnlazada<String>();
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		Peso min = new Peso();
		min.minimo();
		int peso = 0;
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			this.caminoMasCorto(i, mapaCiudades, res, min, lis, peso, ciudad2, marca);
		}
		return res;
	}

	private void caminoMasCorto(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> res, Peso min,
			ListaGenericaEnlazada<String> lis, int peso, String ciudad2, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			if (peso < min.getPeso()) {
				res.comenzar();
				while (!res.esVacia()) {
					res.eliminarEn(0);
				}
				lis.comenzar();
				while (!lis.fin()) {
					res.agregarFinal(lis.proximo());
				}
				min.setPeso(peso);
			}
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			Arista<String> arista;
			ady.comenzar();
			while (!ady.fin()) {
				arista = ady.proximo();
				int j = arista.verticeDestino().posicion();
				if (!marca[j]) {
					this.caminoMasCorto(j, grafo, res, min, lis, peso + arista.peso(), ciudad2, marca);
				}
			}
		}
		lis.eliminarEn(lis.tamanio() - 1);
		marca[i] = false;
	}

	@SuppressWarnings("unused")
	private void dijkstra(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> lis, String ciudad2) {// Dijkstra(G,w,
																											// s){
		ListaGenerica<Arista<String>> ady = null;
		Integer[] D = new Integer[grafo.listaDeVertices().tamanio()];
		Integer[] P = new Integer[grafo.listaDeVertices().tamanio()];
		boolean[] C = new boolean[grafo.listaDeVertices().tamanio()];
		int j, k = i, l;
		boolean llegue = false;
		for (j = 0; j < grafo.listaDeVertices().tamanio(); j++) {// (1) para cada vértice v Є V
			D[j] = null;// (2) Dv = ∞; Pv = 0;
			P[j] = 0;
			C[j] = false;
		}
		D[i] = 0;// (3) Ds = 0;
		for (j = 0; j < grafo.listaDeVertices().tamanio() && !llegue; j++) {// (4) para cada vértice v Є V {
			int min = Integer.MAX_VALUE, posMin = 0;
			for (k = 0; k < grafo.listaDeVertices().tamanio(); k++) {// (5) u = vérticeDesconocidoMenorDist;
				if ((!C[k]) && (D[k] != null)) {
					if (D[k] < min) {
						min = D[k];
						posMin = k;
					}
				}
			}
			C[posMin] = true;// (6) Marcar u como conocido;
			Vertice<String> v = grafo.listaDeVertices().elemento(posMin);
			ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			while (!ady.fin()) {// (7) para cada vértice w Є V adyacente a u
				Arista<String> arista = ady.proximo();
				l = arista.verticeDestino().posicion();
				if (!C[l]) {// (8) si (w no está conocido)
					Vertice<String> w = arista.verticeDestino();
					if (D[l] > (D[v.posicion()] + arista.peso())) {// (9) si (Dw > Du + c(u,w)) {
						D[l] = (D[v.posicion()] + arista.peso());// (10) Dw = Du + c(u,w);
						P[l] = v.posicion();// (11) Pw = u;
					}
					if (arista.verticeDestino().dato().equals(ciudad2)) {
						llegue = true;
						k = j;
						break;
					}
				}
			}
		}
		if (llegue) {
			int pos = k;
			while (D[pos] != 0) {
				lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
				pos = P[pos];
			}
			lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
		}
	}

	@SuppressWarnings("unused")
	private void caminoMinNoPesado(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> lis, String ciudad2) {
		ListaGenerica<Arista<String>> ady = null;
		Integer[] D = new Integer[mapaCiudades.listaDeVertices().tamanio()];
		Integer[] P = new Integer[mapaCiudades.listaDeVertices().tamanio()];
		int j, k = i;
		boolean llegue = false;
		for (j = 0; j < grafo.listaDeVertices().tamanio(); j++) {
			D[j] = null;
			P[j] = 0;
		}
		Cola<Vertice<String>> q = new Cola<Vertice<String>>();
		q.encolar(grafo.listaDeVertices().elemento(i));
		D[i] = 0;
		while (!q.esVacia() && !llegue) {
			Vertice<String> v = q.desencolar();
			ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			while (!ady.fin()) {
				Arista<String> arista = ady.proximo();
				j = arista.verticeDestino().posicion();
				if (D[j] == null) {
					Vertice<String> w = arista.verticeDestino();
					D[j] = D[v.posicion()] + 1;
					P[j] = v.posicion();
					if (arista.verticeDestino().dato().equals(ciudad2)) {
						llegue = true;
						k = j;
						break;
					}
					q.encolar(w);
				}
			}
		}
		if (llegue) {
			int pos = k;
			while (D[pos] != 0) {
				lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
				pos = P[pos];
			}
			lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
		}

	}

	/*
	 * El método caminoSinCargarCombustible(String ciudad1, String ciudad2, int
	 * tanqueAuto): ListaGenerica<String> // Retorna la lista de ciudades que forman
	 * un camino para llegar de ciudad1 a ciudad2. El auto no debe quedarse sin
	 * combustible y no puede cargar. Si no existe camino retorna la lista vacía.
	 */
	public ListaGenerica<String> caminoSinCargarCombustible(String ciudad1, String ciudad2, int tanqueAuto) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.caminoSinCargarCombustible(i, mapaCiudades, res, ciudad2, tanqueAuto, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}

	private boolean caminoSinCargarCombustible(int i, Grafo<String> grafo, ListaGenerica<String> lis, String ciudad2,
			int tanqueAuto, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				Arista<String> arista = ady.proximo();
				if ((tanqueAuto - arista.peso()) >= 0) {
					int j = arista.verticeDestino().posicion();
					if (!marca[j]) {
						llegue = this.caminoSinCargarCombustible(j, grafo, lis, ciudad2, tanqueAuto - arista.peso(),
								marca);
					}
				}
			}
			if (llegue) {
				return true;
			} else {
				marca[i] = false;
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	/*
	 * El método caminoConMenorCargaDeCombustible (String ciudad1, String ciudad2,
	 * int tanqueAuto): ListaGenerica<String> // Retorna la lista de ciudades que
	 * forman un camino para llegar de ciudad1 a ciudad2 teniendo en cuenta que el
	 * auto debe cargar la menor cantidad de veces. El auto no se debe quedar sin
	 * combustible en medio de una ruta, además puede completar su tanque al llegar
	 * a cualquier ciudad. Si no existe camino retorna la lista vacía.
	 */
	public ListaGenericaEnlazada<String> caminoConMenorCargaDeCombustible(String ciudad1, String ciudad2,
			int tanqueAuto) {
		ListaGenericaEnlazada<String> res = new ListaGenericaEnlazada<String>();
		ListaGenericaEnlazada<String> lis = new ListaGenericaEnlazada<String>();
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		Peso min = new Peso();
		min.minimo();
		int peso = 0;
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			this.caminoConMenorCargaDeCombustible(i, mapaCiudades, res, min, lis, peso, tanqueAuto, tanqueAuto, ciudad2,
					marca);
		}
		return res;
	}

	private void caminoConMenorCargaDeCombustible(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> res,
			Peso min, ListaGenericaEnlazada<String> lis, int peso, int tanqueAuto, int lleno, String ciudad2,
			boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			if (peso < min.getPeso()) {
				res.comenzar();
				while (!res.esVacia()) {
					res.eliminarEn(0);
				}
				lis.comenzar();
				while (!lis.fin()) {
					res.agregarFinal(lis.proximo());
				}
				min.setPeso(peso);
			}
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			Arista<String> arista;
			ady.comenzar();
			while (!ady.fin()) {
				arista = ady.proximo();
				int j = arista.verticeDestino().posicion();
				if (lleno >= arista.peso()) {
					if ((tanqueAuto - arista.peso()) = 0) {
						if (!marca[j]) {
							this.caminoConMenorCargaDeCombustible(j, grafo, res, min, lis, peso + 1,
									lleno - arista.peso(), lleno, ciudad2, marca);
						}
					} else {
						if (!marca[j]) {
							this.caminoConMenorCargaDeCombustible(j, grafo, res, min, lis, peso,
									tanqueAuto - arista.peso(), lleno, ciudad2, marca);
						}
					}
				}

			}
		}
		lis.eliminarEn(lis.tamanio() - 1);
		marca[i] = false;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-06-12 19:40:23.450
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-06-12 19:40:23.450
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-12 19:40:23.545
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package prog3.grafos.utiles;

import prog3.grafos.*;
import prog3.listagenerica.*;
import prog3.util.*;

public class Mapa {

	Grafo<String> mapaCiudades = new GrafoImplListAdy<String>();

	public Mapa(Grafo<String> mapaCiudades) {
		super();
		this.mapaCiudades = mapaCiudades;
	}

	/*
	 * El método devolverCamino (String ciudad1, String ciudad2):
	 * ListaGenerica<String> // Retorna la lista de ciudades que se deben atravesar
	 * para ir de ciudad1 a ciudad2 en caso que se pueda llegar, si no retorna la
	 * lista vacía. (Sin tener en cuenta el combustible).
	 */
	public ListaGenerica<String> devolverCamino(String ciudad1, String ciudad2) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.devolverCamino(i, mapaCiudades, res, ciudad2, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}

	private boolean devolverCamino(int i, Grafo<String> grafo, ListaGenerica<String> lis, String ciudad2,
			boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.devolverCamino(j, grafo, lis, ciudad2, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	/*
	 * El método devolverCaminoExceptuando (String ciudad1, String ciudad2,
	 * ListaGenerica<String> ciudades): ListaGenerica<String> // Retorna la lista de
	 * ciudades que forman un camino desde ciudad1 a ciudad2, sin pasar por las
	 * ciudades que están contenidas en la lista ciudades pasada por parámetro, si
	 * no existe camino retorna la lista vacía. (Sin tener en cuenta el
	 * combustible).
	 */
	public ListaGenerica<String> devolverCaminoExceptuando(String ciudad1, String ciudad2,
			ListaGenerica<String> ciudades) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.devolverCaminoExceptuando(i, mapaCiudades, res, ciudades, ciudad2, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}

	private boolean devolverCaminoExceptuando(int i, Grafo<String> grafo, ListaGenerica<String> lis,
			ListaGenerica<String> excepto, String ciudad2, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		excepto.comenzar();
		while (!excepto.fin()) {
			if (v.dato().equals(excepto.proximo())) {
				return false;
			}
		}
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.devolverCaminoExceptuando(j, grafo, lis, excepto, ciudad2, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				marca[i] = false;
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	/*
	 * El método caminoMasCorto(String ciudad1, String ciudad2):
	 * ListaGenerica<String> // Retorna la lista de ciudades que forman el camino
	 * más corto para llegar de ciudad1 a ciudad2, si no existe camino retorna la
	 * lista vacía. (Las rutas poseen la distancia). (Sin tener en cuenta el
	 * combustible).
	 */
	public ListaGenericaEnlazada<String> caminoMasCorto(String ciudad1, String ciudad2) {
		ListaGenericaEnlazada<String> res = new ListaGenericaEnlazada<String>();
		ListaGenericaEnlazada<String> lis = new ListaGenericaEnlazada<String>();
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		Peso min = new Peso();
		min.minimo();
		int peso = 0;
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			this.caminoMasCorto(i, mapaCiudades, res, min, lis, peso, ciudad2, marca);
		}
		return res;
	}

	private void caminoMasCorto(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> res, Peso min,
			ListaGenericaEnlazada<String> lis, int peso, String ciudad2, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			if (peso < min.getPeso()) {
				res.comenzar();
				while (!res.esVacia()) {
					res.eliminarEn(0);
				}
				lis.comenzar();
				while (!lis.fin()) {
					res.agregarFinal(lis.proximo());
				}
				min.setPeso(peso);
			}
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			Arista<String> arista;
			ady.comenzar();
			while (!ady.fin()) {
				arista = ady.proximo();
				int j = arista.verticeDestino().posicion();
				if (!marca[j]) {
					this.caminoMasCorto(j, grafo, res, min, lis, peso + arista.peso(), ciudad2, marca);
				}
			}
		}
		lis.eliminarEn(lis.tamanio() - 1);
		marca[i] = false;
	}

	@SuppressWarnings("unused")
	private void dijkstra(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> lis, String ciudad2) {// Dijkstra(G,w,
																											// s){
		ListaGenerica<Arista<String>> ady = null;
		Integer[] D = new Integer[grafo.listaDeVertices().tamanio()];
		Integer[] P = new Integer[grafo.listaDeVertices().tamanio()];
		boolean[] C = new boolean[grafo.listaDeVertices().tamanio()];
		int j, k = i, l;
		boolean llegue = false;
		for (j = 0; j < grafo.listaDeVertices().tamanio(); j++) {// (1) para cada vértice v Є V
			D[j] = null;// (2) Dv = ∞; Pv = 0;
			P[j] = 0;
			C[j] = false;
		}
		D[i] = 0;// (3) Ds = 0;
		for (j = 0; j < grafo.listaDeVertices().tamanio() && !llegue; j++) {// (4) para cada vértice v Є V {
			int min = Integer.MAX_VALUE, posMin = 0;
			for (k = 0; k < grafo.listaDeVertices().tamanio(); k++) {// (5) u = vérticeDesconocidoMenorDist;
				if ((!C[k]) && (D[k] != null)) {
					if (D[k] < min) {
						min = D[k];
						posMin = k;
					}
				}
			}
			C[posMin] = true;// (6) Marcar u como conocido;
			Vertice<String> v = grafo.listaDeVertices().elemento(posMin);
			ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			while (!ady.fin()) {// (7) para cada vértice w Є V adyacente a u
				Arista<String> arista = ady.proximo();
				l = arista.verticeDestino().posicion();
				if (!C[l]) {// (8) si (w no está conocido)
					Vertice<String> w = arista.verticeDestino();
					if (D[l] > (D[v.posicion()] + arista.peso())) {// (9) si (Dw > Du + c(u,w)) {
						D[l] = (D[v.posicion()] + arista.peso());// (10) Dw = Du + c(u,w);
						P[l] = v.posicion();// (11) Pw = u;
					}
					if (arista.verticeDestino().dato().equals(ciudad2)) {
						llegue = true;
						k = j;
						break;
					}
				}
			}
		}
		if (llegue) {
			int pos = k;
			while (D[pos] != 0) {
				lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
				pos = P[pos];
			}
			lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
		}
	}

	@SuppressWarnings("unused")
	private void caminoMinNoPesado(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> lis, String ciudad2) {
		ListaGenerica<Arista<String>> ady = null;
		Integer[] D = new Integer[mapaCiudades.listaDeVertices().tamanio()];
		Integer[] P = new Integer[mapaCiudades.listaDeVertices().tamanio()];
		int j, k = i;
		boolean llegue = false;
		for (j = 0; j < grafo.listaDeVertices().tamanio(); j++) {
			D[j] = null;
			P[j] = 0;
		}
		Cola<Vertice<String>> q = new Cola<Vertice<String>>();
		q.encolar(grafo.listaDeVertices().elemento(i));
		D[i] = 0;
		while (!q.esVacia() && !llegue) {
			Vertice<String> v = q.desencolar();
			ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			while (!ady.fin()) {
				Arista<String> arista = ady.proximo();
				j = arista.verticeDestino().posicion();
				if (D[j] == null) {
					Vertice<String> w = arista.verticeDestino();
					D[j] = D[v.posicion()] + 1;
					P[j] = v.posicion();
					if (arista.verticeDestino().dato().equals(ciudad2)) {
						llegue = true;
						k = j;
						break;
					}
					q.encolar(w);
				}
			}
		}
		if (llegue) {
			int pos = k;
			while (D[pos] != 0) {
				lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
				pos = P[pos];
			}
			lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
		}

	}

	/*
	 * El método caminoSinCargarCombustible(String ciudad1, String ciudad2, int
	 * tanqueAuto): ListaGenerica<String> // Retorna la lista de ciudades que forman
	 * un camino para llegar de ciudad1 a ciudad2. El auto no debe quedarse sin
	 * combustible y no puede cargar. Si no existe camino retorna la lista vacía.
	 */
	public ListaGenerica<String> caminoSinCargarCombustible(String ciudad1, String ciudad2, int tanqueAuto) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.caminoSinCargarCombustible(i, mapaCiudades, res, ciudad2, tanqueAuto, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}

	private boolean caminoSinCargarCombustible(int i, Grafo<String> grafo, ListaGenerica<String> lis, String ciudad2,
			int tanqueAuto, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				Arista<String> arista = ady.proximo();
				if ((tanqueAuto - arista.peso()) >= 0) {
					int j = arista.verticeDestino().posicion();
					if (!marca[j]) {
						llegue = this.caminoSinCargarCombustible(j, grafo, lis, ciudad2, tanqueAuto - arista.peso(),
								marca);
					}
				}
			}
			if (llegue) {
				return true;
			} else {
				marca[i] = false;
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	/*
	 * El método caminoConMenorCargaDeCombustible (String ciudad1, String ciudad2,
	 * int tanqueAuto): ListaGenerica<String> // Retorna la lista de ciudades que
	 * forman un camino para llegar de ciudad1 a ciudad2 teniendo en cuenta que el
	 * auto debe cargar la menor cantidad de veces. El auto no se debe quedar sin
	 * combustible en medio de una ruta, además puede completar su tanque al llegar
	 * a cualquier ciudad. Si no existe camino retorna la lista vacía.
	 */
	public ListaGenericaEnlazada<String> caminoConMenorCargaDeCombustible(String ciudad1, String ciudad2,
			int tanqueAuto) {
		ListaGenericaEnlazada<String> res = new ListaGenericaEnlazada<String>();
		ListaGenericaEnlazada<String> lis = new ListaGenericaEnlazada<String>();
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		Peso min = new Peso();
		min.minimo();
		int peso = 0;
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			this.caminoConMenorCargaDeCombustible(i, mapaCiudades, res, min, lis, peso, tanqueAuto, tanqueAuto, ciudad2,
					marca);
		}
		return res;
	}

	private void caminoConMenorCargaDeCombustible(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> res,
			Peso min, ListaGenericaEnlazada<String> lis, int peso, int tanqueAuto, int lleno, String ciudad2,
			boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			if (peso < min.getPeso()) {
				res.comenzar();
				while (!res.esVacia()) {
					res.eliminarEn(0);
				}
				lis.comenzar();
				while (!lis.fin()) {
					res.agregarFinal(lis.proximo());
				}
				min.setPeso(peso);
			}
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			Arista<String> arista;
			ady.comenzar();
			while (!ady.fin()) {
				arista = ady.proximo();
				int j = arista.verticeDestino().posicion();
				if (lleno >= arista.peso()) {
					if ((tanqueAuto - arista.peso()) = 0) {
						if (!marca[j]) {
							this.caminoConMenorCargaDeCombustible(j, grafo, res, min, lis, peso + 1,
									lleno - arista.peso(), lleno, ciudad2, marca);
						}
					} else {
						if (!marca[j]) {
							this.caminoConMenorCargaDeCombustible(j, grafo, res, min, lis, peso,
									tanqueAuto - arista.peso(), lleno, ciudad2, marca);
						}
					}
				}

			}
		}
		lis.eliminarEn(lis.tamanio() - 1);
		marca[i] = false;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-12 19:40:23.547
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-12 19:40:23.548
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-12 19:40:53.213
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package prog3.grafos.utiles;

import prog3.grafos.*;
import prog3.listagenerica.*;
import prog3.util.*;

public class Mapa {

	Grafo<String> mapaCiudades = new GrafoImplListAdy<String>();

	public Mapa(Grafo<String> mapaCiudades) {
		super();
		this.mapaCiudades = mapaCiudades;
	}

	/*
	 * El método devolverCamino (String ciudad1, String ciudad2):
	 * ListaGenerica<String> // Retorna la lista de ciudades que se deben atravesar
	 * para ir de ciudad1 a ciudad2 en caso que se pueda llegar, si no retorna la
	 * lista vacía. (Sin tener en cuenta el combustible).
	 */
	public ListaGenerica<String> devolverCamino(String ciudad1, String ciudad2) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.devolverCamino(i, mapaCiudades, res, ciudad2, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}

	private boolean devolverCamino(int i, Grafo<String> grafo, ListaGenerica<String> lis, String ciudad2,
			boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.devolverCamino(j, grafo, lis, ciudad2, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	/*
	 * El método devolverCaminoExceptuando (String ciudad1, String ciudad2,
	 * ListaGenerica<String> ciudades): ListaGenerica<String> // Retorna la lista de
	 * ciudades que forman un camino desde ciudad1 a ciudad2, sin pasar por las
	 * ciudades que están contenidas en la lista ciudades pasada por parámetro, si
	 * no existe camino retorna la lista vacía. (Sin tener en cuenta el
	 * combustible).
	 */
	public ListaGenerica<String> devolverCaminoExceptuando(String ciudad1, String ciudad2,
			ListaGenerica<String> ciudades) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.devolverCaminoExceptuando(i, mapaCiudades, res, ciudades, ciudad2, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}

	private boolean devolverCaminoExceptuando(int i, Grafo<String> grafo, ListaGenerica<String> lis,
			ListaGenerica<String> excepto, String ciudad2, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		excepto.comenzar();
		while (!excepto.fin()) {
			if (v.dato().equals(excepto.proximo())) {
				return false;
			}
		}
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				int j = ady.proximo().verticeDestino().posicion();
				if (!marca[j]) {
					llegue = this.devolverCaminoExceptuando(j, grafo, lis, excepto, ciudad2, marca);
				}
			}
			if (llegue) {
				return true;
			} else {
				marca[i] = false;
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	/*
	 * El método caminoMasCorto(String ciudad1, String ciudad2):
	 * ListaGenerica<String> // Retorna la lista de ciudades que forman el camino
	 * más corto para llegar de ciudad1 a ciudad2, si no existe camino retorna la
	 * lista vacía. (Las rutas poseen la distancia). (Sin tener en cuenta el
	 * combustible).
	 */
	public ListaGenericaEnlazada<String> caminoMasCorto(String ciudad1, String ciudad2) {
		ListaGenericaEnlazada<String> res = new ListaGenericaEnlazada<String>();
		ListaGenericaEnlazada<String> lis = new ListaGenericaEnlazada<String>();
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		Peso min = new Peso();
		min.minimo();
		int peso = 0;
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			this.caminoMasCorto(i, mapaCiudades, res, min, lis, peso, ciudad2, marca);
		}
		return res;
	}

	private void caminoMasCorto(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> res, Peso min,
			ListaGenericaEnlazada<String> lis, int peso, String ciudad2, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			if (peso < min.getPeso()) {
				res.comenzar();
				while (!res.esVacia()) {
					res.eliminarEn(0);
				}
				lis.comenzar();
				while (!lis.fin()) {
					res.agregarFinal(lis.proximo());
				}
				min.setPeso(peso);
			}
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			Arista<String> arista;
			ady.comenzar();
			while (!ady.fin()) {
				arista = ady.proximo();
				int j = arista.verticeDestino().posicion();
				if (!marca[j]) {
					this.caminoMasCorto(j, grafo, res, min, lis, peso + arista.peso(), ciudad2, marca);
				}
			}
		}
		lis.eliminarEn(lis.tamanio() - 1);
		marca[i] = false;
	}

	@SuppressWarnings("unused")
	private void dijkstra(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> lis, String ciudad2) {// Dijkstra(G,w,
																											// s){
		ListaGenerica<Arista<String>> ady = null;
		Integer[] D = new Integer[grafo.listaDeVertices().tamanio()];
		Integer[] P = new Integer[grafo.listaDeVertices().tamanio()];
		boolean[] C = new boolean[grafo.listaDeVertices().tamanio()];
		int j, k = i, l;
		boolean llegue = false;
		for (j = 0; j < grafo.listaDeVertices().tamanio(); j++) {// (1) para cada vértice v Є V
			D[j] = null;// (2) Dv = ∞; Pv = 0;
			P[j] = 0;
			C[j] = false;
		}
		D[i] = 0;// (3) Ds = 0;
		for (j = 0; j < grafo.listaDeVertices().tamanio() && !llegue; j++) {// (4) para cada vértice v Є V {
			int min = Integer.MAX_VALUE, posMin = 0;
			for (k = 0; k < grafo.listaDeVertices().tamanio(); k++) {// (5) u = vérticeDesconocidoMenorDist;
				if ((!C[k]) && (D[k] != null)) {
					if (D[k] < min) {
						min = D[k];
						posMin = k;
					}
				}
			}
			C[posMin] = true;// (6) Marcar u como conocido;
			Vertice<String> v = grafo.listaDeVertices().elemento(posMin);
			ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			while (!ady.fin()) {// (7) para cada vértice w Є V adyacente a u
				Arista<String> arista = ady.proximo();
				l = arista.verticeDestino().posicion();
				if (!C[l]) {// (8) si (w no está conocido)
					Vertice<String> w = arista.verticeDestino();
					if (D[l] > (D[v.posicion()] + arista.peso())) {// (9) si (Dw > Du + c(u,w)) {
						D[l] = (D[v.posicion()] + arista.peso());// (10) Dw = Du + c(u,w);
						P[l] = v.posicion();// (11) Pw = u;
					}
					if (arista.verticeDestino().dato().equals(ciudad2)) {
						llegue = true;
						k = j;
						break;
					}
				}
			}
		}
		if (llegue) {
			int pos = k;
			while (D[pos] != 0) {
				lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
				pos = P[pos];
			}
			lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
		}
	}

	@SuppressWarnings("unused")
	private void caminoMinNoPesado(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> lis, String ciudad2) {
		ListaGenerica<Arista<String>> ady = null;
		Integer[] D = new Integer[mapaCiudades.listaDeVertices().tamanio()];
		Integer[] P = new Integer[mapaCiudades.listaDeVertices().tamanio()];
		int j, k = i;
		boolean llegue = false;
		for (j = 0; j < grafo.listaDeVertices().tamanio(); j++) {
			D[j] = null;
			P[j] = 0;
		}
		Cola<Vertice<String>> q = new Cola<Vertice<String>>();
		q.encolar(grafo.listaDeVertices().elemento(i));
		D[i] = 0;
		while (!q.esVacia() && !llegue) {
			Vertice<String> v = q.desencolar();
			ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			while (!ady.fin()) {
				Arista<String> arista = ady.proximo();
				j = arista.verticeDestino().posicion();
				if (D[j] == null) {
					Vertice<String> w = arista.verticeDestino();
					D[j] = D[v.posicion()] + 1;
					P[j] = v.posicion();
					if (arista.verticeDestino().dato().equals(ciudad2)) {
						llegue = true;
						k = j;
						break;
					}
					q.encolar(w);
				}
			}
		}
		if (llegue) {
			int pos = k;
			while (D[pos] != 0) {
				lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
				pos = P[pos];
			}
			lis.agregarInicio(grafo.listaDeVertices().elemento(pos).dato());
		}

	}

	/*
	 * El método caminoSinCargarCombustible(String ciudad1, String ciudad2, int
	 * tanqueAuto): ListaGenerica<String> // Retorna la lista de ciudades que forman
	 * un camino para llegar de ciudad1 a ciudad2. El auto no debe quedarse sin
	 * combustible y no puede cargar. Si no existe camino retorna la lista vacía.
	 */
	public ListaGenerica<String> caminoSinCargarCombustible(String ciudad1, String ciudad2, int tanqueAuto) {
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		ListaGenerica<String> res = new ListaGenericaEnlazada<String>();
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			llegue = this.caminoSinCargarCombustible(i, mapaCiudades, res, ciudad2, tanqueAuto, marca);
			if (!llegue && (res.tamanio() == 1)) {
				res.eliminarEn(0);
			}
		}
		return res;
	}

	private boolean caminoSinCargarCombustible(int i, Grafo<String> grafo, ListaGenerica<String> lis, String ciudad2,
			int tanqueAuto, boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			return true;
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			ady.comenzar();
			boolean llegue = false;
			while (!ady.fin() && !llegue) {
				Arista<String> arista = ady.proximo();
				if ((tanqueAuto - arista.peso()) >= 0) {
					int j = arista.verticeDestino().posicion();
					if (!marca[j]) {
						llegue = this.caminoSinCargarCombustible(j, grafo, lis, ciudad2, tanqueAuto - arista.peso(),
								marca);
					}
				}
			}
			if (llegue) {
				return true;
			} else {
				marca[i] = false;
				lis.eliminarEn(lis.tamanio() - 1);
				return false;
			}
		}
	}

	/*
	 * El método caminoConMenorCargaDeCombustible (String ciudad1, String ciudad2,
	 * int tanqueAuto): ListaGenerica<String> // Retorna la lista de ciudades que
	 * forman un camino para llegar de ciudad1 a ciudad2 teniendo en cuenta que el
	 * auto debe cargar la menor cantidad de veces. El auto no se debe quedar sin
	 * combustible en medio de una ruta, además puede completar su tanque al llegar
	 * a cualquier ciudad. Si no existe camino retorna la lista vacía.
	 */
	public ListaGenericaEnlazada<String> caminoConMenorCargaDeCombustible(String ciudad1, String ciudad2,
			int tanqueAuto) {
		ListaGenericaEnlazada<String> res = new ListaGenericaEnlazada<String>();
		ListaGenericaEnlazada<String> lis = new ListaGenericaEnlazada<String>();
		boolean[] marca = new boolean[mapaCiudades.listaDeVertices().tamanio()];
		Peso min = new Peso();
		min.minimo();
		int peso = 0;
		boolean llegue = false;
		int i = -1;
		ListaGenerica<Vertice<String>> vert = mapaCiudades.listaDeVertices();
		vert.comenzar();
		while (!vert.fin() && !llegue) {
			Vertice<String> dest = vert.proximo();
			if (dest.dato().equals(ciudad1)) {
				i = dest.posicion();
				llegue = true;
			}
		}
		if (i >= 0) {
			llegue = false;
			this.caminoConMenorCargaDeCombustible(i, mapaCiudades, res, min, lis, peso, tanqueAuto, tanqueAuto, ciudad2,
					marca);
		}
		return res;
	}

	private void caminoConMenorCargaDeCombustible(int i, Grafo<String> grafo, ListaGenericaEnlazada<String> res,
			Peso min, ListaGenericaEnlazada<String> lis, int peso, int tanqueAuto, int lleno, String ciudad2,
			boolean[] marca) {
		marca[i] = true;
		Vertice<String> v = grafo.listaDeVertices().elemento(i);
		lis.agregarFinal(v.dato());
		if (v.dato().equals(ciudad2)) {
			if (peso < min.getPeso()) {
				res.comenzar();
				while (!res.esVacia()) {
					res.eliminarEn(0);
				}
				lis.comenzar();
				while (!lis.fin()) {
					res.agregarFinal(lis.proximo());
				}
				min.setPeso(peso);
			}
		} else {
			ListaGenerica<Arista<String>> ady = grafo.listaDeAdyacentes(v);
			Arista<String> arista;
			ady.comenzar();
			while (!ady.fin()) {
				arista = ady.proximo();
				int j = arista.verticeDestino().posicion();
				if (lleno >= arista.peso()) {
					if ((tanqueAuto - arista.peso()) = 0) {
						if (!marca[j]) {
							this.caminoConMenorCargaDeCombustible(j, grafo, res, min, lis, peso + 1,
									lleno - arista.peso(), lleno, ciudad2, marca);
						}
					} else {
						if (!marca[j]) {
							this.caminoConMenorCargaDeCombustible(j, grafo, res, min, lis, peso,
									tanqueAuto - arista.peso(), lleno, ciudad2, marca);
						}
					}
				}

			}
		}
		lis.eliminarEn(lis.tamanio() - 1);
		marca[i] = false;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-06-12 19:40:53.214
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-06-12 19:40:53.214
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2242)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
!SESSION 2022-07-09 16:52:14.141 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_AR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-07-09 16:52:39.355
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-09 16:52:39.355
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7e76a66f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@72237be8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-07-09 16:52:39.355
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5c5f12e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@23f8036d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-07-09 16:52:43.393
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Joaco'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
